{"contribute.html":{"url":"contribute.html","title":"贡献文章","keywords":"","body":"如何贡献项目 HandsFree是一个希望推动国内机器教育的开源项目,如果你感兴趣，可以参与该Wiki的教程编写，作为社区回馈,我们会根据提交的教程水准,赠送作者机器人相关配件，书籍，雷达，摄像头，以及HandsFree机器人平台等。 只要提交教程就有礼品喔～。 概述 本wiki以Gitbook的形式编写,源文件存储于: https://github.com/mawenke/handsfree_wiki 特殊目录介绍 docs　目录用于存放md文件 images　目录用于存放md引用的图片 docs/Tutorial/ 目录用于存放机器人的开发实验教程,主要是基于ROS. docs/Tutorial/Advanced　下的教程独立性比较高，且一般是由各路大神补充的教程,所以图片和md文件放在同目录 docs/Courses 目录用于存放机器人教育的相关学习教程. docs/Courses/Advanced　下的教程独立性比较高，且一般是由各路大神补充的教程,所以图片和md文件放在同目录 如何贡献文档 在Github上fork　作者的HandsFree Wiki源文件: https://github.com/mawenke/handsfree_wiki 在自己的本地仓库上编辑更改文档后用Github　的Pull Requests功能提交自己的更新给作者的仓库 语法和排版规范 使用GitHub支持的Markdown语言，可参考HandsFree的 markdown 教程 。 一个小节从大标题开始，到三标题会自动生成悬浮目录，标题不能是链接或者图片 标题不需要标注1，2，3．．．等序号，序号由插件自动生成 正文前不需要空格 图片和本地文件的引用，请用相对链接 图片全部用.jpg格式，vedio使用.mp4格式，GIF需要压缩竟可能小于3M 本开源书籍遵循 中文排版指南 规范。 排版模板 # 如何贡献项目　　 //本小节大标题，从大标题开始到三标题会自动生成悬浮目录，标题不能是链接或者图片 //标题不需要标注1，2，3．．．等序号，序号由插件自动生成 //正文前不需要空格 HandsFree是一个希望推动国内机器教育的开源项目,如果你感兴趣，可以参与该Wiki的教程编写，作为社区回馈,我们会根据提交的教程水准,赠送作者机器人相关配件，书籍，雷达，摄像头，以及HandsFree机器人平台等。 > 只要提交教程就有礼品喔～。 ## 概述　　 // 本小节二标题，标题不需要标注序号 本wiki以[Gitbook](https://www.gitbook.com)的形式编写,源文件存储于: [https://github.com/mawenke/handsfree_wiki](https://github.com/mawenke/handsfree_wiki) 特殊目录介绍 * docs　目录用于存放md文件 * images　目录用于存放md引用的图片 * docs/Tutorial/ 目录用于存放机器人的开发实验教程,主要是基于ROS. * docs/Tutorial/Advanced　下的教程独立性比较高，且一般是由各路大神补充的教程,所以图片和md文件放在同目录 * docs/Courses 目录用于存放机器人教育的相关学习教程. * docs/Courses/Advanced　下的教程独立性比较高，且一般是由各路大神补充的教程,所以图片和md文件放在同目录 Copyright © 深圳朝闻道智能信息科技有限公司 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-06-25 18:43:12 "},"./":{"url":"./","title":"综合介绍","keywords":"","body":"概述 HandsFree 是一个面向机器人研究、开发的开源软硬件系统。她有完备与科学的框架,以优秀的嵌入式系统框架为核心,精良的电路、机械设计为支撑,帮您快速实现多种形态的机器人。本系统包含机器人导航,SLAM,计算机视觉等模块,并拥有自己上层软件和调试系统。她支持国外其他的开源项目,如 ROS, MPRT, PIXHAWK 等,这一切都为您带来了无比的便捷和快乐! HandsFree 2018 HandsFree 2017 社区建设 HandsFree Github HandsFree Website HandsFree Wiki 社区交流群: 521037187 (Hands Free Community) 联系邮箱： hands_free@126.com 资料直通车 HandsFree 项目介绍PPT HandsFree 百度云 HandsFree 主控原理图 HandsFree 嵌入式OpenRE的教程 HandsFree 机器人的底层通信接口 目前已有国内一百多家高校、科研机构采用HandsFree开源系统 资源索引 西北工业大学布树辉教授个人网站 RosClub Exbot 易科实验室 产品介绍 HandsFree 拥有系统完整的软硬件产品，使您更加便捷的进行机器人应用的开发 购买地址：淘宝店铺 机器人 Mini Stone Giraffe 无人机实时测绘系统 RTMpper 周边产品 HFARM 巴克 HandsFree Mini 机器人平台 轻小灵动，游刃有余 小身形，多功能。高集成度多功能控制器、强劲续航动力、完善的开发教程，让你以最低的成本快速入门机器人开发学习。 外形及性能参数 详细介绍 点击购买 Mini　　 　　　　　　　　Mini 详细信息 HandsFree Stone 机器人平台 墨雅敦庄，举重若轻 多功能通用型机器人研究开发平台，内外兼修，集成专业的控制系统，适用于机器人相关领域的研究和产品Demo研发。 外形及性能参数 详细介绍 点击购买 Stone　　 　　　　　　　　Stone 详细信息 HandsFree Giraffe 机器人平台 心有猛虎，细嗅蔷薇 多功能重量级机器人研究开发平台，65Kg大载重、20Ah的大容量、双激光雷达和双深度摄像头的设计，支持大型机械臂，集成专业的控制系统，让你以最快速度完成高端服务型机器人的应用开发。 外形及性能参数 详细介绍 点击购买 Giraffe　　 　　　　　 　Giraffe 详细信息 HandsFree RTMapper 无人机系统 详细介绍 RTMapper 详细信息 周边产品 HandsFree 机械臂 HandsFree 机械臂是HandsFree研发的第一款机械臂。其拥有5个自由度，能实现顺畅自如地旋转、伸缩、抓取等动作。HFArm 总重10Kg，采用直流电机作为伺服动力。为了降低臂根弯矩，降低对伺服电机的扭矩需求，提高机械臂的稳定性与定位精度，HFArm采用了将伺服电机固定在臂根而用同步带将扭矩传至臂稍关节的布局。HFArm的抓取水平范围为（0.46m,0.9m），周向旋转角度大于180度。 巴克 巴克是18自由度智能人形机器人，使用优必选公司的数字舵机。整机共有9个钣金件、2个铣件、2个线切割铝件及7个3D打印件。为统一全机机械安装标准，各零部件间连接皆采用M2的螺钉及螺母。巴克配备有高清双目摄像头和语音识别系统，能准确地识别出不同颜色的不同物体及不同的语音命令。良好的机械结构设计让巴克能轻松完成俯卧撑、劈叉、航母Style等高难度的动作。正是基于这些引人注目的设计，巴克才能获得“2014中国机器人大赛暨Robcup公开赛”自创双足人形组一等奖。 Copyright © 深圳朝闻道智能信息科技有限公司 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-09-13 11:39:30 "},"docs/About/":{"url":"docs/About/","title":"关于","keywords":"","body":"概述 HandsFree 是一个面向机器人研究、开发的开源软硬件系统。她有完备与科学的框架,以优秀的嵌入式系统框架为核心,精良的电路、机械设计为支撑,帮您快速实现多种形态的机器人。本系统包含机器人导航,SLAM,计算机视觉等模块,并拥有自己上层软件和调试系统。她支持国外其他的开源项目,如 ROS, MPRT, PIXHAWK 等,这一切都为您带来了无比的便捷和快乐! HandsFree 2018 HandsFree 2017 社区建设 HandsFree Github HandsFree Website HandsFree Wiki 社区交流群: 521037187 (Hands Free Community) 联系邮箱： hands_free@126.com 资料直通车 HandsFree 项目介绍PPT HandsFree 百度云 HandsFree 主控原理图 HandsFree 嵌入式OpenRE的教程 HandsFree 机器人的底层通信接口 目前已有国内一百多家高校、科研机构采用HandsFree开源系统 资源索引 西北工业大学布树辉教授个人网站 RosClub Exbot 易科实验室 产品介绍 HandsFree 拥有系统完整的软硬件产品，使您更加便捷的进行机器人应用的开发 购买地址：淘宝店铺 机器人 Mini Stone Giraffe 无人机实时测绘系统 RTMpper 周边产品 HFARM 巴克 HandsFree Mini 机器人平台 轻小灵动，游刃有余 小身形，多功能。高集成度多功能控制器、强劲续航动力、完善的开发教程，让你以最低的成本快速入门机器人开发学习。 外形及性能参数 详细介绍 点击购买 Mini　　 　　　　　　　　Mini 详细信息 HandsFree Stone 机器人平台 墨雅敦庄，举重若轻 多功能通用型机器人研究开发平台，内外兼修，集成专业的控制系统，适用于机器人相关领域的研究和产品Demo研发。 外形及性能参数 详细介绍 点击购买 Stone　　 　　　　　　　　Stone 详细信息 HandsFree Giraffe 机器人平台 心有猛虎，细嗅蔷薇 多功能重量级机器人研究开发平台，65Kg大载重、20Ah的大容量、双激光雷达和双深度摄像头的设计，支持大型机械臂，集成专业的控制系统，让你以最快速度完成高端服务型机器人的应用开发。 外形及性能参数 详细介绍 点击购买 Giraffe　　 　　　　　 　Giraffe 详细信息 HandsFree RTMapper 无人机系统 详细介绍 RTMapper 详细信息 周边产品 HandsFree 机械臂 HandsFree 机械臂是HandsFree研发的第一款机械臂。其拥有5个自由度，能实现顺畅自如地旋转、伸缩、抓取等动作。HFArm 总重10Kg，采用直流电机作为伺服动力。为了降低臂根弯矩，降低对伺服电机的扭矩需求，提高机械臂的稳定性与定位精度，HFArm采用了将伺服电机固定在臂根而用同步带将扭矩传至臂稍关节的布局。HFArm的抓取水平范围为（0.46m,0.9m），周向旋转角度大于180度。 巴克 巴克是18自由度智能人形机器人，使用优必选公司的数字舵机。整机共有9个钣金件、2个铣件、2个线切割铝件及7个3D打印件。为统一全机机械安装标准，各零部件间连接皆采用M2的螺钉及螺母。巴克配备有高清双目摄像头和语音识别系统，能准确地识别出不同颜色的不同物体及不同的语音命令。良好的机械结构设计让巴克能轻松完成俯卧撑、劈叉、航母Style等高难度的动作。正是基于这些引人注目的设计，巴克才能获得“2014中国机器人大赛暨Robcup公开赛”自创双足人形组一等奖。 Copyright © 深圳朝闻道智能信息科技有限公司 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-09-13 11:39:30 "},"docs/About/Project-Overview.html":{"url":"docs/About/Project-Overview.html","title":"项目介绍","keywords":"","body":"HandsFree 组成 项目虽然看起来涉及很广，但目前主要任务大概有三个。 一 OpenRE 库 全称 Open Source Robot Embedded Library，也就是机器人嵌入式库。简单的说，其作用与国外知名的无人机开发架构 pixhawk 类似，只不过 pixhwak 主要是面向飞行器，而 OpenRE 则是面向多模态机器人的。 Download OpenRE 二 多模态平台设计 我们的开发项目和开发平台是多样化的，比如二轮，三轮的移动机器人，四旋翼固定翼飞行器等，重复造轮子的问题是机器人学者和创业者最常遇到的问题，好的系统是要求很好的泛性的，能够适应大部分平台，避免了重复劳动的弊端，这就要求我们的产品更加多元化。 在多模态机器人平台搭建方面，研究的主要内容是设计精良的机械和电路系统。机械系统包括各种模型的机器人躯体、机械臂、云台等。电路则包含控制系统，驱动电路，电源管理系统，硬件调试等方面。 多模态平台旨在以机器人学，自动化，通信电子和周边知识为支撑，搭建科学、鲁棒、友好、统一的机器人硬件系统，以配合整个软硬件系统的统一 为了促进社区交流，我们开源了大部分的设计资料，请看百度云 三 系统搭建 主要是基于前两个任务，结合团队在 SLAM， 物体识别，机器人任务规划等研究，以及国外知名的 ROS 等开源项目，搭建整个机器人系统，实现一些应用。 自主移动模块框架搭建 物体识别模块 机械臂控制模块 多机器人协同 HandsFree Github 总结 我们希望HandsFree 成为一套可以遵循的标准，而不仅仅只是一个工程，所以我们精心制定了电路设计标准和机械设计标准，并且公开了我们团队的PCBLIB和机械模型库，凡是照着这个标准来设计的机器人将会很大程度的兼容HandsFree的软件系统，我们希望此举让更多的机器人研究者得到便利，也希望有心人帮助我们完善这个标准的内容。 PIL 介绍 西北工业大学布树辉教授的智能系统实验室开发的跨平台软件库 PIL，支持多线程、时钟、插件、网络、常用硬件抽象、计算机视觉、GUI等功能。布老师是我人生中最敬佩导师，他不仅有着超强的工程和科研能力，而且和蔼可亲，亦师亦友，手把手教，更难得的是，他比学生们还要努力，总是走在团队的最前面带着每个学生奋斗，喜欢机器人或者无人机领域的伙伴们可以关注一下他的个人网站，如果想读他研究生或者博士的伙伴也可以来联系群主。 HandsFree开源机器人项目综合介绍 Copyright © 深圳朝闻道智能信息科技有限公司 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-06-05 20:21:40 "},"docs/About/About-US.html":{"url":"docs/About/About-US.html","title":"关于我们","keywords":"","body":"概述: 就像歌里唱的那样，HandsFree才不是一个没有故事的男同学，大家在学习和使用HandsFree的同时，肯定也对HandsFree的过去有所好奇吧。 2015年的秋天注定是个不平凡的季节。我的一位学长获得了保研资格，而他在舞蹈机器人基地的电子组摸爬滚打了两年之后，终于迎来了脱离底层（嵌入式层）的机会。机器人学是一个庞杂的学科，学习机器人需要形成一个较为完整的体系，于是学长准备在大四阶段和研究生阶段转移到ROS和SLAM上的研究。但是他又不舍得将自己多年来积累的嵌入式层的知识和经验就此抛弃，于是HandsFree的构想诞生了。顾名思义，HandsFree就是解放双手。而在机器人学中，解放双手最好的办法无疑就是解决机器人学中重复造轮子的问题。HandSFree的嵌入式部分OpenRE就是将市面上使用较为流行的几款芯片统一打包，进行机器人底层驱动的编写，并进行封装。让使用HandsFree的机器人研究者们真正地面向机器人进行开发，而不用关心底层的细节，大大缩短了开发时间节省了开发精力。 HandsFree经历了两年时间的缓慢发展,变得越来越完善,也吸引了越来越多的志同道合的伙伴加入,HandsFree也慢慢的走向正规的发展趋势. 关于我们: 当你热爱某种事物，你可能会想办法去弥补它身上的缺点，即使意味着会牺牲你一点点，我们只是一群呆在大学里幼稚青年，但我们也有着对机器人事业的向往。 HandsFree， 顾名思义解放双手。 我们想做到的是能够搭建一个共享的平台，一个友好的易于共同开发的框架。HandsFree 从嵌入式平台开始，逐步地扩展到了相应的其他周边，为的是让整个机器人的开发过程降低耦合，尽可能地减少一些底层的开发环节，在开发过程中提供了一个更好的交流方式。HandsFree 其理念核心是优化开发过程的同时，让设计的 idea 的分享过程更加 Free，是乐于分享的，鼓励分享的。 HandsFree Team 是一个乐于奉献于机器人事业的团队，我们希望能为每一个走进机器人世界的学者带来便利。HandsFree 理念总结成一句话：创造一个机会共同成长。 如果你觉得不错的话，就一起加入进来吧！！！ 理念： 探索，成长，分享 宗旨： 以学习和科研为第一要义，对知识和技术的追求永无止境，不断创新，精益求精，提升自我； 其次，尽能力承担一定的社会责任，重视分享； 最后，鼓励创造社会价值和财富以维持长期发展。 内容： HandsFree 是一个面向机器人研究、开发的开源软硬件系统。她有完备与科学的框架， 以优秀的嵌入式系统框架为核心， 精良的电路、 机械设计为支撑，帮您快速实现多种形态的机器人。本系统包含机器人导航，SLAM，计算机视觉等模块， 并拥有自己上层软件和调试系统。 她支持国外其他的开源项目， 如 ROS,MPRT, PIXHAWK 等，这一切都为您带来了无比的便捷和快乐！ 现状： HandsFree 是一个机器人开源项目，涵盖了和机器人相关的许多方面。我们面向开源的主要任务是搭建一个机器人系统， 并且尽可能使用各种工具来实现目的。 HandsFree 人员由 HandsFree Team ， HandsFree Community 组成。 HandsFree Team 是 HandsFree 的缔造者和主要开发人员，负责更新，管理，建设 HandsFree 开源社区。目前 HandsFree 团队主要是由西北工业大学，厦门大学等几所大学的学生或者实验室组成。 HandsFree Community ，指所有参与，使用该开源项目的伙伴构建的交流圈,我们的交流QQ群是521037187 (Hands Free Community)。 我们希望能有志同道合的人加入我们，一起学习交流。 团队: 西安酷科迪乐智能科技有限公司 HandsFree团队聚集了一批有实力的机器人开发与研究者，他们目前主要来源于西北工业大学的舞蹈机器人基地和智能系统实验室。团队的成员，都具有三年以上的机器人相关领域的研究经历，涵盖了机器人学，机器人系统和控制，视觉SLAM，机器学习，目标跟踪等。八个技术核心成员都有五年以上的一线工程经验，大家在一起本着开源的精神和发展机器人事业的共同理想，探索HandsFree的发展方向，维护HandsFree社区的良好运转。 历史贡献者: 舞蹈机器人基地: 西北工业大学舞蹈机器人基地是西工大唯一一个完全自主开发实物机器人的创新基地。经过多年发展，现已形成篮球机器人、舞蹈机器人、家政机器人、救援机器人四个项目组。其中，舞蹈机器人处于国内统治地位，救援机器人、家政机器人作为所有参赛队伍中唯一的本科生队伍也连续几年取得非常优秀的比赛成绩，刚刚成立的篮球机器人项目组作为今年的新起之秀已取得备受瞩目的成绩。基地十余年来坚持以技术为基础，现分为软件、电子、机械三个技术组。 智能系统实验室: 西北工业大学智能系统实验室,主要从事视觉SLAM, 大场景三维重建,场景解析，目标检测，三维形状分析，环境变化检测等研究,详细信息请看 : PILab Copyright © 深圳朝闻道智能信息科技有限公司 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-06-02 16:12:07 "},"docs/About/Why-HandsFree.html":{"url":"docs/About/Why-HandsFree.html","title":"为什么要有HandsFree","keywords":"","body":"社区人士对HansFree的评价 布树辉教授 Northwestern Polytechnical UniversityYouyi west road #127, Xi'an 710072, Chinae-mail: bushuhui@nwpu.edu.cnhomepage: http://www.adv-ci.com 我们正处在一个人工智能大变革的时代，高智能的软件、机器人越来越多的出现在我们的生活中，在这波浪潮中我们要怎么应对？我觉得大家无可避免的面对了一个非常巨大的挑战和机遇，机器人作为人工智能的载体必将在未来起到越来越重要的作用。未来的20年，我们所处的世界必将发生巨大的变化，所以我们必须面对这样的变化，不管你的专业是什么，其实都与机器人有或多或少的关系。为了更好的学习机器人技术，如果有一套设计精良的机器人平台将会极大加快学习、研究的速度。HandsFree是一个非常优秀的开源机器人平台，使用这个平台可以让你很快就构建一个机器人系统，得益于优秀的架构设计，能够支持多种形态的机器人形态，利用自主开发的开源OpenRE机器人中间件，能够极大的降低机器人程序开发的难度。 HandsFree创始人是西工大机器人基地的马文科，他是我见过学生中最有追求、最有理想的学生，和他共同工作的一年中，我深深受到了他那种坚韧不拔、努力学习的感染。受到他的感染，目前HandsFree吸引了20多个成员围绕机械、硬件、软件、算法开展学习、研究工作。他们通过无私的工作在为机器人事业奉献自己的力量，他们身上体现了机器人基地培养出来同学对机器人事业的热爱，看到中国机器人事业发展壮大的希望。他们做出的成果都通过开源的形式共享给大家，能够深切的感受到他们愿意从自身开始，为推动中国机器人开源平台事业向前发展的愿景。 HandsFree是一个乐于奉献于机器人事业的团队，希望能为每一个走进机器人世界的爱好者带来便利。HandsFree 理念是：探索，成长，分享，创造一个机会共同成长。如果觉得不错，就一起加入HandsFree的大家庭吧，保证你会在这里得到能力的提升！ 张瑞雷 (zhangrelay) 张瑞雷，在高校从事多机器人系统仿真和编队控制研究与教学工作，Exbot机器人实验室成员，ROS星火计划讲师，热衷于机器人和人工智能前沿技术的教学和传播，希望能为国内开源机器人社区贡献自己一份力量。 易科机器人(Exbot)成员 : http://blog.exbot.net/个人博客 ： http://my.csdn.net/ZhangRelay优酷： http://i.youku.com/zhangrelay翻译书籍： ROS机器人程序设计（原书第2版） 自从接触并学习研究机器人系统这10多年过程中，一直在寻找一款上手简易，功能丰富，定制灵活，扩展性强的机器人平台。不仅出于自己测试算法的需要，也是为了方便相关方法的推广和教学，在这期间，不经意间发现了HardsFree。其实我觉得这款平台最大的优势也就是解放双手，不需要自己搭建电路，设计模具等，从而实现了Mind-Creative，让我可以更多的去关注机器人的大脑，即算法的开发与测试。这是一款简约不简单ROS机器人平台，值得拥有。 田博（贾子枫） 南京天之博特机器人科技有限公司创始人, ROS星火计划讲师博客：http://tianb03.blogspot.com/知乎：https://www.zhihu.com/people/tianb03/ROS机器人培训与就业请关注微信公众号：天之博特（tianzhibote） HandsFree 每次在ROS的课程上我都会讲到，我们取之于开源，却少有人回馈开源。很多研究单位做一点小小的改进都敝帚自珍，这对于机器人行业在国内的发展是极为不利的，长此以往，讲什么赶超美国日本欧洲都是空谈！终于，我们盼到了Handsfree，国内机器人开源社区的一股清流，软硬件全部开源，而且研发团队也是国内一流！虽然比起老牌的Pioneer，Turtlebot等平台，Handsfree还略显稚嫩，但是他们在中文学习资源、社区以及软件配套上，都是其他平台无法比拟的，已有国内机器人开源平台执牛耳者的风范。希望大家能够关心HandsFree，支持HandsFree，共建开源机器人大社区，推动我国的移动机器人的人才培养、技术水平以及产业发展！ 刘昌祥 原2011届西工大舞蹈机器人基地家政视觉组成员 对于我们这种机械和电子都很苦手的程序员来说，有一个容易上手并且好用的平台，可以节省大量的不必要的时间。HandsFree给我提供了这种便利。设计贴心，组装简单易懂，核心板的排线开始比较难插（第一代），但是掌握技巧以后就很容易组装了。我应该是最早订购HF的那批，拿到的是初代HF原型机（后来才知道那个黄色的膜其实可以撕掉，撕掉以后就变成晶莹剔透，立马又高大上几个档次），尽管是初代，已经可以体会到是研发团队的心血之作。HF的机器帮助我完成了很多实验的验证，包括RL引导的机器人避障行为研究等，在最初选择的时候我也考虑过turtlrbot这些常用的机器人平台，但是HF以它极高的性价比打动了我。选择HF，是最正确的选择。 雷一鸣 我叫雷一鸣，是一名热爱机器人的大四老油条，来自武汉的一所普通一本院校。我在14年的时候就接触到 ROS 和 TurtleBot2 ，在校期间担任学院机器人队的学生负责人，主要负责学生竞赛和自主机器人开发等。自主开发机器人博客移步 -> http://leiym.com/2016/05/05/tank1/ 简而言之，HandsFree 是一套完全开源的基于ROS的自主导航轮式机器人平台。首先相对于 TurtleBot2 只开源了上位机程序，并没有开源底层源码的半开源，HandsFree 不仅开源了底层控制板程序，甚至连控制板的硬件部分都开源出来，免费地提供给爱好者DIY。其次， HandsFree 通信层基于 ros_controller 开发，经过了长时间跨平台的测试，保证了机器人运行过程中的可靠性。最后， HandsFree 使用了 Kinect 或者 Xtion 等成本低，可靠性高的 RGBD 摄像机，使用最为成熟的 gmapping 来作为SLAM的关键技术，因此，HandsFree 能够保证性能出众的同时也能做到低价。总而言之，HandsFree 是一款非常好的ROS平台，不仅可以让新手快速入门学习ROS，又能够让学校企业可以低成本地专注研究集群等热门机器人领域。 个人觉得 HandsFree 团队的开源情怀和敬业态度值得敬佩。在国内其实类似的ROS机器人卖家很多，我也接触过其他具体的产品，不过真正让我感受到不一样的地方是 HandsFree 对待买家的态度，电机人为因素烧坏了立马更换、不管是不是买家，只要有人提问了，社区群里的团队成员们也是尽力解答。不论机器人还是开源库， HandsFree 的开源精神都能帮助到更多的西恩ROSer，让更多的人体会到西恩开源的力量。 甜甜的柚子 杭州电子科技大学博客园 : https://home.cnblogs.com/u/eat-too-much/ 现在的开源项目个人觉得以计算机互联网为盛，涉及嵌入式的项目个人觉得不多。EE想转CS的，不可谓不多。我也曾经想过，EE实在是太繁杂了，小到电烙铁，大到示波器，有的时候还经常出现莫名其妙的情况，百思不得其解。有些不了了之。有些恍然大悟。而计算机的人，太多的人写博客，太多的人愿意分享，讨论，一句“PHP是最好的语言”，有些群便可以炸了锅。。。 HandsFree 是我毕设的指路人吧。我是做底板的。上层的我没有很深入的接触。handsfree的这种分享精神真的值得我们对电子有兴趣的人认真学习，当你是“小白”的时候，好问，当你是“大牛”的时候，好答。作为每一方其实都有许些收货与精进。同时应该尊重开源知识，或者是遵守相应的开源协议。 一方风景 学校:电子科技大学中山学院实验室:中山市嵌入式系统公共实验室Github:https://github.com/TifferPelodeCSDN:http://blog.csdn.net/tifferpelode HANDSFREE开源项目是一个对ROS学习者来说很好的实验平台，具有高拓展性和鲁棒性。对于掌握了ROS基础知识，急需实物来进一步学习的人提供了一个理想的实践平台，项目全开源也使我们可以在其原有的基础上做适合自己想法的功能。 Copyright © 深圳朝闻道智能信息科技有限公司 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-06-02 16:12:07 "},"docs/About/Story-And-Wine.html":{"url":"docs/About/Story-And-Wine.html","title":"故事和酒","keywords":"","body":"HandsFree 故事和酒 2017.4.15 记   今天就是想和大家聊聊HandsFree。   HandsFree是一个开源的移动机器人开发平台，后来学长们把它做成了社区。   它怎么来的呢？   两年前，学校舞蹈机器人基地有个电子组学长，在基地电子组干了得有两年多，几乎把基地各个项目电子组的活儿都摸了个遍。有天他敲代码连续敲了有13个小时，突然发现自己的手累的都没办法抬起来了。   这学长懒啊，然后他就想，我特么一个电子组的整天在这儿这么苦逼的敲代码,不行啊,以后我要解放双手，去搞上层啊。以后一定要造一套轮子，不管要做啥机器人，都不用重新写一遍代码，不用重新调PID，自己就再也不用干这些底层的重复性民工活儿了,一定要实现HandsFree，那该多好。嗯，这还是一个伟大的梦想，一定会实现的。然后学长就坐那耷拉着手开始嘿嘿嘿笑起来了。。。。   没想到的是，他这么懒的一个人有了这样一个念头之后，真的就忘不了了。。。他想搞机器人啊，他真的觉得自己以后很有可能就天天搞机器人了，既然这样，他就一定要造一套好轮子，能够实现HandsFree，让自己专心做有前途的上层。于是，就在大三快放暑假的时候，在他刚刚感到有大把时间可以供自己自由分配的时候，他终于按捺不住了，开始没日没夜的写HandsFree，他就开始朝着自己那个能让自己嘿嘿嘿笑的梦想开始努力了。   其实这学长的学分积已经非常可怜了，80%，在基地厮混了这么久，哪里有时间想着照顾学分积呢。但他依然在那个时候，在准备考研的时候，疯狂的敲了一个暑假。开学之后，他本来准备忍痛放下HandsFree,复习考研。但没想到，那一年政策变化，80%的他居然也成功保研。。。听到这消息他立马就把考研书扔一边儿，屁颠儿屁颠儿又跑过去整HandsFree了。   第一版写完之后,学长非常开心的把HandsFree的嵌入式库分享给老学长,老学长看完之后说这玩意儿不错啊，我们还能用呢。他又很开心的分享给狗哥他们，狗哥他们也说好。后来就说，这么好的玩意儿咱别自己用了，咱整开源吧。起个好名字，就叫OpenRE（Open Robot Embedded）。然后狗哥刚好还和Exbot的管理员关系不错,易科就说你们这玩意儿也挺不错的,我们帮你们推广下吧。一推广就火了，大家建了个群，第二天就200人了。   后来啊，要不怎么说兄弟情深，要不怎么说情怀啊。基地他们那一届，A叔，狗哥，陈映冰学长，汪志康学长，邵琪杰学长都在呢，说你干吧，好不容易咱基地也整个开源项目，我们都帮你。从基地退役之后，没了经费，他们搞机器人也要生存啊，那就卖机器人吧，就卖HandsFree机器人。   以上这些,就是我对HandsFree历史的一些粗浅印象,可能有失实和夸张的部分。   问过学长之后,他给了我当时的一篇日记(2016.1.3)原文如下:   四个月前，我决定慢慢脱离底层，但是在这之前，我要把之前搞过的东西总结成一个库，方便以后再次使用时不需要再次研究底层的东西，并且这个库要具备强大的可移植性，可扩展性，完备精简，方便快捷，我大概花了一周的时间搭好一个基本框架，并使用ROS Package 和 Node的概念，以便于扩展各种功能包，并把所有MCU相关的代码有条理的封装成一个和MCU同名的文件夹，使用C++方式来封装每个功能包，同时把操作系统组件封装到一个文件夹，这样，即使一个不懂嵌入式的人，也可以很轻松的用这个库来开发。   然而做到这一步，并没有我一开始想的那么轻松，我花了1个半月的时间，改了好几版，才写好一个仅仅支持STM32F1的库，这一个半月，让我痛苦不堪，每天一醒来就在写，写到着整层楼的人都睡了，天天如此，我当时唯一的念头就是，一旦写好，我就可以HANDS FREE了，并且全部开源的念头也是在这种情景上诞生的，我希望别人不要在干这种浪费生命的活，我把这第一个版本命名HANDS-FREE-V1.0发布在基地里，希望有人和我一起搞。   可是现实并不美好，除了获得几个赞外，啥都没有，关键时刻还得靠基友啊，于是我去找陈映冰，把我的想法告诉他，正好那个时候，他在搞移动平台，并且正在着死画板子，敲着死代码，可以说是和我之前的情景一样，于是我们一拍即和，两个人精心配合一直到现在，在合作的两个月里，我们一起制定了HANDS-FREE-PCB的协议和统一的lib，一起完善制定开展了模块化PCB思想，一起精心设计ALL FOR ONE的主控的一代，二代，三代，他还设计了HANDS-FREE的电机驱动，并且一起完善了HANDS-FREE嵌入式框架在STM32 F4平台上的支持性，那段时间，我们基本天天通过语音来合作，也有好几次想要放弃，更要命的是，我们各自不满对方的想法，直接在QQ上开始撕逼大战，不过还好他脾气好，不然HANDS-FREE就夭折了，我和他也基本完成了硬件和嵌入式的框架，总而言之，没有他，我早就放弃了，他是我在HANDS-FREE项目中最给力的助攻。   也是在和陈映冰搞了一个月后，我想到我毕设需要3个移动平台，于是我找到汪志康帮我设计机械部分，我的毕设和廖新一一起做，做了HANDS-FREE这么久，移动平台自然是要在HANDS-FREE的基础上完成的，于是建立机械标准的想法自然就诞生了，于是HandsFree就变成了一个以嵌入式框架为核心，机械，硬件为分之的平台了，汪志康很给力，虽然他不太懂硬件和嵌入式，不过他却很支持HANDS-FREE的理念，他定义HANDS-FREE机械标准和设计了,HANDS-FREE-Robot-3WD V1.0,也是他让我想到这个硬件平台是可以为更多人服务的。   发布HANDS-FREE1.0后，我就把阵营搬到毕设教研室，也就是说后面的进程，我都是在教研室搞的，毕设是ROS,在这段时间里，我做了一个决策，让HANDS-FREE以ROS机器人开发的开源平台的形式推广出去，机器人越来越火，需要以机器人开发平台的人也越来越多，而国内基本没有一个好的开源平台，HANDS-FREE已经封装了机械，硬件，和嵌入式，而且廖新一在EXBOT上的影响力不小，所以我们具备了很多可以推广的条件，于是我开始规划HANDS-FREE的推广计划。   后面的发展和一开始规划的差不多，我们和EXBOT达成了合作关系，只不过让我没想到的是，EXBOT先来找我，而不是我去找他，我更坚定了这个平台的需求，我们约定，1个月也就是2月1号之前，在EXBOT官网上推出HANDS-FREE-Robot-3WD，他们负责ROS教程编写和宣传HANDS-FREE，接着我说服了我的毕设导师，和教研室达成了合作，于是我们有了资金和后续技术支持，教研室负责视觉SLAM和机器学习的软硬件开发，接着找到邵琪杰，于是HANDS-FREE-Robot-人形也就加入进来了，后来在基地发布了HANDS-FREE-Robot-1.5，吸引了一些学长以及他们的创业团队和基地小伙伴们，HANDS-FREE的维护成员于是开始增长，我相信，随着越来越多的人加入进来，HANDS-FREE的目标很快就会实现。   后来HandsFree团队内的人聚聚散散，车也是有空了造几台卖一把。16年上半年干的比较起劲，暑假还去了好多学校和公司讲了讲HandsFree。但是下半年研究生就开学了，大家都有课，都有一堆新的人在等着自己认识。发展速度就慢慢慢了下来。但是因为社区早已经建起来了，当时在我们这批还在基地服役的队员里面。。。HandsFree的名声还是神秘而装逼的。。。。   去年冬天的时候，学长跑到基地来拉皮条了。自己一个人带着个PPT。我就舔着脸认识了学长。我们一些人也就趁着比赛帮学长推广项目的名义加进了HandsFree。   大学，是每个人的青春。不甘寂寞的人总是会寻找各式各样的出路，来度过漫长四年。或者是学生会、社团，运动会，又或者是加基地，进实验室。我们把自己最黄金的两年多时间投入到里面，以至于很多年后回想大学生涯，这依然会是我们的谈资。有些人，很难能可贵的，就会在这个过程中找到自己想要的东西。   学长，就是这样的一个人。基地，就是这样的一个组织。我们在这里发现对机器人的热爱，很多人就从这里开始走上了一条以前从未想象过的道路。   至于我，现在正大三，过年前本来想的是这学期要放弃一切竞赛，准备安心学习复习的。本来参加比赛的时候想的就是帮学长打个宣传，宣传完也就没事了。。。但没想到真的越陷越深了。。。   一开始是在和学长有过一次快四个小时的长谈之后，真的是被他这种对机器人的热爱和开源精神打动了，我发现我们两个在很多理念上非常契合。开源精神，听起来像做公益，像做慈善。但是谁让我真的有这方面的愿望呢。一路走来，很多地方都曾受人恩惠，被人提携。我们每个人其实都是在社会成长，利用社会的资源，也要尽可能的回报社会。曾想着是等自己有大把大把的钱了，再回报社会。但随着自己在“马克思主义道路”（一本正经脸）上感触越来越深，思考的就慢慢的变了。何必非等到以后呢？所行就是所想，所做就是为人。真想回报社会，就不会找借口等到以后。你就从现在做起，从能摸得到的身边人做起，帮助他们，这就是回报社会。   更何况，HandsFree里面还寄托着一群人对机器人的梦想。想一想我们在搞的机器人，中国现在做智能机器人的核心青年力量，都是曾参加过中国机器人大赛，RoboCup的一批人。然而近几年随着一批顶尖高校的退水（转向国际赛放弃国内赛），和比赛本身生命周期的发展，真正甩着膀子在这个比赛上往前冲的人越来越少了。仔细想想，中国现在到底有多少机器人人才储备军啊？985高校的学生可能在本科生阶段会比较单纯的参与进去，但是到了大四或者研究生，被实验室的项目牵着走，转而追求一些其他的东西了。再加上有些实验室的保密氛围或者封闭性，除了发论文卖产品之外，能为这个社会机器人事业的发展贡献的力量就更少了。可是你看啊，中国未来对机器人的需求是多么巨大。现在行业对机器人人才的渴望是多么强烈。原先互联网时代那群人是多么希望跟上时代步伐也来开发机器人。现在的国内虽然有易科这样的机器人社区，但是对很多想入手机器人的人来说，还是缺少一个开放友好的机器人开发平台啊。   还有时代在发展,技术在迅速的进步。每一年顶会上发的论文趋势都在变化。你拼了命的学习，看代码，还不一定赶得上熟悉前沿技术，更别说投入那么长的时间调机器人了。   机械、电子、软件都在发展，仅就基地而言，软件组从三年前开始引入ROS,去年开始上深度学习FasterRcnn,三年前出去的人现在回来看都不一定跟的上了。有人说，你就一个本科生，比赛需求还那么低，搞那么多牛逼的东西干啥？基础的东西你都学完了吗？时代在发展啊，大兄弟。几百年前人们花几十年时间学习牛顿定律，但是当他发展成熟之后，今天我们一本初中课本就能让你学完最核心的知识。生产力发展的需求在推着时代往前走，不断的弃旧扬新。不断的压缩远离时代的知识的学习时间，把时间挤出来发展新技术，新应用，提高生产力。一代人有一代人的使命，上一代人搞好的东西，交到你手里，你就可以直接用，是让你来发展新东西的。07年别人拿PCA做个人脸识别，还是个挺新的玩意儿，今年你还拿他来做创新实践，得了吧，半天实验熟悉一遍就做完了。你要是时间充裕还行，别人已经造出来的东西，你就跑过去复现一遍，体会创造思想，但也仅此打住。不要再浪费时间了。时间是多么宝贵啊，你花时间学习旧的，是为了发展新的啊。这么多东西等着你学，你还守在过去的一个炕里面站不起来啊。   很多人说害怕未来人工智能机器人时代到来他们失业,但其实对我们这群搞机器人的人来说,这恰恰就是我们的事业啊,未来几十年内，这么好的机会就再等着我们呢。HandsFree把整个的嵌入式软硬件开发环境都移植到了Linux上，OpenRE还把一系列机器人开发过程中的嵌入式代码进行了封装，出于实际机器人开发经验的需要，丰富了很多接口（包括电源。通信，调试这些），而且实现了全开源。后来我们把它总结成叫：分布式架构设计、硬件资源预留以及软件开放性优化。她极大的方便了这群搞ROS的人根据任务需要进行底层DIY，以及一群以前玩儿电子的人进入ROS。她这么一套东西，是真的能省去大量的开发时间的，以前开发个机器人准备比赛可能需要六七个人从头花七八个月的时间，但是用HandsFree之后，可能三四个人三四个月就能整个差不多了。   也就是说，她这个东西是真的能推动一批人进入到机器人学习中来，推动开源机器人事业的发展，为社会带来贡献的。西工大好不容易能出来这么一个被社会评价很好的开源社区，为什么不扶一把呢，这也算是西工大学生的社会担当，西工大在机器人开源社区对社会的贡献。公为天下，即从今日始。报效祖国，就从手边干啊。这么说，可能有点太伟光正，但是为什么就不能伟光正一点，把我们的初衷表达出来呢？   想通了这一点之后，我就决定加入HandsFree了。我们啊，搞HandsFree，真的是出于我们在基地培养出来的对机器人事业的热爱，是看到中国机器人事业发展壮大的希望，是愿意从我们自身开始，推动中国机器人开源平台事业向前发展的愿景。是开源精神。是在互联网时代开放氛围下成长学习的我们，也愿意和别人，和走在同一条道路上的人，分享经验，共同成长的共享精神。这是HandsFree团队凝聚在一起的精神支柱。   说起来团队，HandsFree团队现在稳定的队员不到10人，都还是西工大上学的学生。团队内部机械、电子、ROS，视觉，运营干啥的人也有。鼎力支持我们的老师是航空学院的教授布树辉老师。他们实验室在搞的是视觉SLAM和无人机。和HandsFree有非常紧密的联系。HandsFree要干的事情也很多，技术开发，教程编写，开源产品设计，网站搭建，社区推广等等。。   为了技术开发,我们要赶紧把底层要完善发展的工作做完。然后赶紧开始视觉SLAM，机器学习的学习。   为了维持团队正常运行花费，我们还忙着运营卖小车赚经费，给团队添置一些材料设备。   为了让HandsFree能被更多的人知道,我们还要忙着参加重量级的比赛进行宣传,整理好网站和社区方便推广。   之前有人问我们有什么困难。想了半天想不出来。我们到现在一直都是很幸运的。布老师不遗余力，不求回报的帮助我们，师兄师姐也始终支持我们。每有一个人肯帮助我们，我们都感到万分幸运。团队现在能不定期的进行技术交流会，有自己的局域网千兆带宽服务器，能有钱买自己的VPN，能顺利的卖六七十台车，在开心的时候挤出一点钱去吃顿大餐。社区发展到500人多，使用者涉及全国30多家高校和科研院所跟公司。包括中科院，哈工大，厦大，电科里面好多好多人都在我们社区里面。我们等于是站在巨人的肩膀上，被大家一把一把扶着起来的。我们是真心的感谢那些帮助过我们的人，不管是给我们在技术上提供支持，还是在团队发展、宣传上给我们提建议，还是帮我们转发推送，真的真的感谢你们。真要说现在哪里困难，就是我们现在技术上的难题甘之如饴，但商业化问题十分头痛。缺少精通运营，推广的人来帮助我们。上次去珠海,感触最深的就是时代的发展.大西北太封闭了,不管是社会文化还是科技发展，到珠三角才是触摸时代的前沿,这里这么多机会等着你抓住,这么多资源等着人来用。机器人这么前沿的东西就在这里，你要不去攻占，明天就可能被别人占领。   现在几个人忙里忙外累死累活也能勉强维持前进，但是人无远虑，必有近忧。团队也是啊，团队现在有不少人都面临着就业上研或者考研的抉择，等我们走了之后，不想让HandsFree就这么没了,我们还是真心的希望能再找到一些人和我们一起走下去,能找到在各方面都有些特长，还能热爱机器人的人，来储备一批发展力量。   大学青春时光宝贵，能找到这样一个团队，大家一起喝酒吃肉，指点江山,这是多么荡气回肠的事啊！ Copyright © 深圳朝闻道智能信息科技有限公司 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-06-02 16:12:07 "},"docs/Products/":{"url":"docs/Products/","title":"产品介绍","keywords":"","body":"概述 HandsFree 是一个面向机器人研究、开发的开源软硬件系统。她有完备与科学的框架,以优秀的嵌入式系统框架为核心,精良的电路、机械设计为支撑,帮您快速实现多种形态的机器人。本系统包含机器人导航,SLAM,计算机视觉等模块,并拥有自己上层软件和调试系统。她支持国外其他的开源项目,如 ROS, MPRT, PIXHAWK 等,这一切都为您带来了无比的便捷和快乐! HandsFree 2018 HandsFree 2017 社区建设 HandsFree Github HandsFree Website HandsFree Wiki 社区交流群: 521037187 (Hands Free Community) 联系邮箱： hands_free@126.com 资料直通车 HandsFree 项目介绍PPT HandsFree 百度云 HandsFree 主控原理图 HandsFree 嵌入式OpenRE的教程 HandsFree 机器人的底层通信接口 目前已有国内一百多家高校、科研机构采用HandsFree开源系统 资源索引 西北工业大学布树辉教授个人网站 RosClub Exbot 易科实验室 产品介绍 HandsFree 拥有系统完整的软硬件产品，使您更加便捷的进行机器人应用的开发 购买地址：淘宝店铺 机器人 Mini Stone Giraffe 无人机实时测绘系统 RTMpper 周边产品 HFARM 巴克 HandsFree Mini 机器人平台 轻小灵动，游刃有余 小身形，多功能。高集成度多功能控制器、强劲续航动力、完善的开发教程，让你以最低的成本快速入门机器人开发学习。 外形及性能参数 详细介绍 点击购买 Mini　　 　　　　　　　　Mini 详细信息 HandsFree Stone 机器人平台 墨雅敦庄，举重若轻 多功能通用型机器人研究开发平台，内外兼修，集成专业的控制系统，适用于机器人相关领域的研究和产品Demo研发。 外形及性能参数 详细介绍 点击购买 Stone　　 　　　　　　　　Stone 详细信息 HandsFree Giraffe 机器人平台 心有猛虎，细嗅蔷薇 多功能重量级机器人研究开发平台，65Kg大载重、20Ah的大容量、双激光雷达和双深度摄像头的设计，支持大型机械臂，集成专业的控制系统，让你以最快速度完成高端服务型机器人的应用开发。 外形及性能参数 详细介绍 点击购买 Giraffe　　 　　　　　 　Giraffe 详细信息 HandsFree RTMapper 无人机系统 详细介绍 RTMapper 详细信息 周边产品 HandsFree 机械臂 HandsFree 机械臂是HandsFree研发的第一款机械臂。其拥有5个自由度，能实现顺畅自如地旋转、伸缩、抓取等动作。HFArm 总重10Kg，采用直流电机作为伺服动力。为了降低臂根弯矩，降低对伺服电机的扭矩需求，提高机械臂的稳定性与定位精度，HFArm采用了将伺服电机固定在臂根而用同步带将扭矩传至臂稍关节的布局。HFArm的抓取水平范围为（0.46m,0.9m），周向旋转角度大于180度。 巴克 巴克是18自由度智能人形机器人，使用优必选公司的数字舵机。整机共有9个钣金件、2个铣件、2个线切割铝件及7个3D打印件。为统一全机机械安装标准，各零部件间连接皆采用M2的螺钉及螺母。巴克配备有高清双目摄像头和语音识别系统，能准确地识别出不同颜色的不同物体及不同的语音命令。良好的机械结构设计让巴克能轻松完成俯卧撑、劈叉、航母Style等高难度的动作。正是基于这些引人注目的设计，巴克才能获得“2014中国机器人大赛暨Robcup公开赛”自创双足人形组一等奖。 Copyright © 深圳朝闻道智能信息科技有限公司 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-09-13 11:39:30 "},"docs/Products/Mini.html":{"url":"docs/Products/Mini.html","title":"Mini机器人","keywords":"","body":"Mini机器人 概述 轻小灵动，游刃有余 小身形，多功能。高集成度多功能控制器、强劲续航动力、完善的开发教程，让你以最低的成本快速入门机器人开发学习。 外形及性能参数 设计特点 Mini是一款采用前万向后差速底盘布局的小型机器人开发平台。其主体结构由四层超高强度哑黑E-CR玻纤板和九根高强度亮银铝柱组成，使得只有书本大小的它拥有6Kg的载重能力。Mini搭载了基于32位STM32F103芯片的多功能控制器，在方寸之间集成了电源管理系统、蓝牙模块、电机驱动和六轴惯性传感器；5800mAh的高品质防爆聚合物锂电子电池和两个7.5W的电机赋予了Mini出色的运动能力。一如既往，Mini传承了HFR机器人系列高通用化、高拓展性的血统，可支持多款主流的激光雷达、单板计算机、RGBD摄像头，能运行HFR的任何软件，同时也支持OpenRE机器人库和ROS系统，配合完善的开发手册和活跃的交流社区，使用户能快速上手。娇小的体型并导致性能上的任何压缩，反而赋予了它非比寻常的灵活性和可亲的价格，Mini是初学入门和多机集群研究的不二之选。 套餐价格　　　　　　　　　　　　　　　 点击购买 Mini　　 　　　　　 Mini 套餐 属性 价格(不带发票) 基础版 1. 机械结构 2. 控制电路，电源电路，配套开发调试硬件，电池套装x1 3. 技术手册，社区支持，技术交流和指导 (不提供免费教学培训) 1998 RMB 导航开发版 1. 基础版全部内容 2. Intel Atom 4核4GB/32GB (可跑Rviz 和Stage) 3. rplidar a1(激光雷达) 3698 RMB 视觉开发版(推荐) 1. 导航开发版全部内容 2. 微软Kinect1 4498 RMB 视觉增强版 1. 基础版全部内容 2. 酷睿i3 4G/64G SSD控机 + rplidar a1(激光雷达)3. 微软Kinect1 5498 RMB 实验演示 Mini小巧玲珑，售价底，适合学生入门和用于研究多机器人协同。然而Mini虽然小，却五脏俱全，在移动，建图，导航，避障方面的效果并不会比Stone 和 Giraffe 差，只是载重小，不能放机械臂，PC，这样就限制了机器人其他方面的研究，所以需要更高平台需求的可以看Stone和Giraffe 基于深度强化学习的多机器人去中心化避障实验 by Dorabot 去中心化的多机器人避障（decentralized multi-robot collision avoidance） 目标在与多机器人系统在没有中心服务器规划，甚至机器人间没有通讯的情况下，也能拥有高效， 无震荡（Oscillation-Free）机器人避障行为。可以类比在拥挤的街道上行走的人们。基于handsfree 我们构建了完善的实验平台，在我们的实验中，handsfree极大减少了底层开发的难度，加速了我们实物机器人实验进程。 Copyright © 深圳朝闻道智能信息科技有限公司 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-08-02 22:24:55 "},"docs/Products/Stone.html":{"url":"docs/Products/Stone.html","title":"Stone机器人","keywords":"","body":"Stone机器人 概述 墨雅敦庄，举重若轻 多功能通用型机器人研究开发平台，内外兼修，集成专业的控制系统，适用于机器人相关领域的研究和产品Demo研发。 外形及性能参数 设计特点 Stone是一款采用前万向后差速驱动底盘布局的中型机器人开发平台。其主体结构由高强度哑黑E-CR玻纤板和2020型磨砂黑铝合金柱螺接而成，使得Stone拥有15Kg载重能力的同时也拥有墨黑儒雅的风度。Stone采用了基于32位STM32F407芯片的多功能控制器OpenRE Board，拥有丰富的板载资源和二次开发接口，还集成了十轴惯性测量单元。Stone搭载Power Manager电源管理系统，在拥有电池充放电保护、过流过压保护、电量显示等功能的同时，还能向外界提供5V、12V和19V的稳定电能输出，让用户摆脱上层设备供电不便的烦恼。Stone的设计从用户角度出发，设计了双急停开关和航空通信插头，在顶部搭载2自由度云台、13.3寸IPS显示器和高保真双音响，让整机布局科学合理，人机交互变得更为简单便捷。一如既往，Stone传承了HFR机器人系列高通用化、高拓展性的血统，可支持多款主流的激光雷达、单板计算机、RGBD摄像头。更不一样的是，Stone支持主流的桌面机械臂，如Dobot、7Bot等，让你玩转桌面应用。Stone支持OpenRE机器人库和ROS系统，完善的开发教程，满足ROS开发、SLAM研究者的需求，适用于机器人相关领域的研究和产品Demo研发。 套餐价格　 点击购买 Stone　　 Stone 套餐 属性 价格(不带发票) 基础版 1. 机械结构(包含底盘、支杆，显示器)，不包含机械臂、云台 2. 控制电路，电源电路，配套开发调试硬件，电池套装x1 3. 技术手册，社区支持，技术交流和指导 (不提供免费教学培训) 9700 RMB 导航低配版(推荐) 1. 基础版全部内容 2. 酷睿 i3 4G/64G SSD工控机 + rplidar a2(激光雷达) 14400 RMB 导航高配版 1. 基础版全部内容 2. 酷睿 i7 8G/120G SSD工控机 + rplidar a2(激光雷达) 15900 RMB 视觉低配版 1. 导航低配版全部内容 2. PrimeSense Xtion RGBD 摄像头 + 云台 16800 RMB 视觉高配版(推荐) 1. 导航高配版全部内容 2. PrimeSense Xtion RGBD 摄像头 + 云台 3. 无线键鼠、PS3遥控器 18800 RMB 豪华版 1. 视觉高配版 2. Dobot 机械臂（带吸盘、手抓、气泵） 28800 RMB 定制版 1. 定制传感器，设备，控制器，培训教学服务，高校机器人实验室搭建 2. 定制 导航/识别/跟踪/抓取功能 ，RoboCup 比赛培训（保拿国家级一等奖） ¥¥¥¥¥ RMB 实验演示 综合来说，Stone已经很好的个人机了，有一定的载重能力，支持Dobot机械臂，适合小实验室和个人机器人研究。但是还不能完成一些复杂的任务，比如抓取一瓶水，开个门，负载也有限，所以有更高需求的请看Giraffe，Giraffe有着庞大的身躯和超大的负载能力，可以支持HandsFree，或者配合Hands机械臂和UR系列的机械臂，可以胜任大部分的机器人研究任务。 Copyright © 深圳朝闻道智能信息科技有限公司 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-08-02 22:24:57 "},"docs/Products/Giraffe.html":{"url":"docs/Products/Giraffe.html","title":"Giraffe机器人","keywords":"","body":"Giraffe机器人 概述 心有猛虎，细嗅蔷薇 多功能重量级机器人研究开发平台，65Kg大载重、20Ah的大容量、双激光雷达和双深度摄像头的设计，支持大型机械臂，集成专业的控制系统，让你以最快速度完成高端服务型机器人的应用开发。 外形及性能参数 设计特点 Giraffe是一款采用前万向后差速驱动底盘布局的准工业级机器人开发平台。其主体结构由高强度哑黑E-CR玻纤板、2020型磨砂黑高强度铝合金柱和6061航空铝合金板螺接而成，使得Giraffe拥有高达65Kg的载重能力。Giraffe采用了基于32位STM32F407芯片的多功能控制器OpenRE Board，拥有丰富的板载资源和二次开发接口，还集成了十轴惯性测量单元。Giraffe搭载Power Manager电源管理系统，在拥有电池充放电保护、过流过压保护、电量显示等功能的同时，还能向外界提供5V、12V、19V和24V的稳定电能输出，让用户摆脱上层设备供电的烦恼。秉承科学、人性化的设计理念，Giraffe设计了双急停开关和航空通信插头，在两侧采用带磁吸的可开合门式结构，并设计了零件收纳抽屉、笔记本电脑支架，让接线、调试变得随意起来。在顶部，Giraffe搭载有2自由度云台、13.3寸IPS显示器和高保真双音响，让整机布局科学合理，人机交互变得更为简单便捷。一如既往，Giraffe传承了HFR机器人系列高通用化、高拓展性的血统，它支持前后两个各主流型号的激光雷达，能兼容各主流的通用计算机和RGBD摄像头。另外，坚固、高可靠度的结构设计使得Giraffe能支持HandsFree大型机械臂和UR3/5机械臂，能满足更多服务机器人的任务要求。Giraffe支持OpenRE机器人库和ROS系统，完善的开发教程和售后技术服务，满足ROS开发、SLAM研究，机器视觉研究的需求，适用于工业机器人产品的研究开发。 套餐价格　购买 点击购买 Giraffe　　 Giraffe 套餐 属性 价格(不带发票) 基础版 1. 机械结构(底盘 + 云台，不含机械臂) 2. 控制电路，电源电路，配套开发调试硬件，电池套装x1 3. 无线键鼠，PS3遥控器 3. 技术手册，社区支持，技术交流和指导(不提供免费教学培训) 18000 RMB 低配版 1. 基础版全部内容 2. 七代双核酷睿i7工控机 3. rplidar a3(激光雷达) 4. PrimeSense Xtion RGBD 摄像头 30000 RMB 中配版(机器学习版) 1. 基础版全部内容 2. Hokuyo UST-10LX(雷达) 3. PrimeSense Xtion RGBD 摄像头 + 双目ZED 4. 四核酷睿i5HQ(16GB/256GB SSD) + GTX1060 (6G 独显) 48000 RMB 高配版(推荐) 1. 基础版全部内容 2. Hokuyo UTM-30Lx(雷达) 3. PrimeSense Xtion RGBD 摄像头 + 双目ZED 4. 四核酷睿i5HQ(16GB/256GB SSD) + GTX1060 (6G 独显) 80000 RMB 定制版 1. 定制传感器，设备，控制器，培训教学服务，高校机器人实验室搭建 2. 定制 导航/识别/跟踪/抓取功能 ，RoboCup 比赛培训（保拿国家级一等奖） ¥¥¥¥¥ RMB 定制机械臂 1.HandsFree 4自由度机械臂 + 末端夹持器，工作空间0.8m，末端负载2kg 2. 提供抓取桌面常见物品的Demo(可乐瓶子、方块、罐子等) 60000 RMB 实验演示 Giraffe在建图导航避障方面的效果和Stone , Mini一样，这里就主要展示一下大型机械臂的3D运动规划和抓取，Giraffe是目前HandsFree功能最全，性能最强的平台，也是HandsFree Team目前研究机器人领域的主要实验平台。 Copyright © 深圳朝闻道智能信息科技有限公司 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-08-02 22:24:58 "},"docs/Products/RTMapper.html":{"url":"docs/Products/RTMapper.html","title":"RTMapper无人机系统","keywords":"","body":"RTMapper无人机系统 概述 功能应用 套餐价格　 RTMapper 套餐 属性 价格(不带发票) 基础版 1. 硬件设备(包含DJIMAVIC PRO，PC地面站，手机APP)2. 技术手册，社区支持，技术交流和指导 15W RMB 地图测绘版 1. 基础版全部内容2.高精度无人测绘系统使用授权 30W RMB 详细介绍 需要购买和进一步了解 RTMapper 请邮箱联系： hands_free@126.com Copyright © 深圳朝闻道智能信息科技有限公司 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-06-02 16:12:07 "},"docs/Products/Comparison.html":{"url":"docs/Products/Comparison.html","title":"和Turtlebot的对比","keywords":"","body":"HandsFree与Turtlebot对比 参数对比汇总 参数类型 Mini Stone Giraffe Turtlebot2 Burger Waffle 高度(mm) 320 1081 1502 124.8 192 141 直径(mm) 230 400 441/399 351.5 140/180 280/306 重量(kg) 2 8 20 5 1 1.8 负载能力(kg) 6 15 65 5 15 30 最大速度(m/s) 1.2 1.2 2 0.7 0.22 0.26 主控板类型 玩家级主控 专业级主控(丰富的接口和资源) 　 同左 Kobuki底盘 玩家级主控 玩家级主控 是否涵盖电源管理 有 有 有 未知 无 无 电源扩展 12V/3A x 2 , USB5V/2A x 2 19V/3A x 3 , 12V/10A x 5 12V/3A x 4 , USB5V/2A x 2 一路急停12V/10A 24V/30A x 5 , 19V/3A x 3 12V/3A x 4 , USB5V/2A x 2 一路急停12V/30A 12V/5A 12V/1.5A 5V/1A 3.3V/0.8A 5V/4A 12V/1A 3.3V/0.8A 5V/4A 12V/1A 支持外接设备 RplidarA1/A2 Hokuyo URG-04L/UTM-30Lx Xtion1/2，Kinect1/2 TK1，树莓派，工控机 Mini支持的设备 + ZED Camera , Dobot机械臂 1/2 Stone支持的设备 + HandsFree机械臂 参考上述电源接口 参考上述电源接口 参考上述电源接口 电源电压和容量　 12v/5200mAh 12V 16000mAh 24V 20000mAh 12v/2200mAh　　/4400mAh 12v/1800mAh 12v/1800mAh 续航时间（h） 8 12 12 ? 2.5 2 机型级别 低端 中端 高端 中端 低端 低端 教程体系 　 有 有 有 有 有 有 下位机软件 专业机器人库OpenRE 同左 同左 未知 OpenCR 同左 价格(RMB) 1998/35984398/5398 5998/8598/1039812398/15398 12998/2099824598/66998 11399 5500 15500 说明: Turtlebot2除价格外其他参数均为Kobuki移动底盘的参数. Burger和Waffle是Turtlebot3系列平台 价格一栏格式不同的版本 直径为:长,宽 本文档为HandsFree机器人与Turtlebot公司机器人的对比报告,.报告内容将从硬件,软件,售后三个方面来进行对比. 概述 HandsFree HandsFree 是一个面向机器人研究、开发的开源软硬件系统。有完备与科学的框架,以优秀的嵌入式系统框架为核心,精良的电路、机械设计为支撑,帮您快速实现多种形态的机器人。本系统包含机器人导航,SLAM,计算机视觉等模块,并拥有自己上层软件和调试系统。她支持国外其他的开源项目,如 ROS, MPRT, PIXHAWK 等,这一切都为您带来了无比的便捷和快乐! HandsFree现在主推三款机器人分别是Mini,Stone,Giraffe,分别面向不同需求.简介如下:Mini是一款采用前万向后双驱动轮底盘布局的小型机器人。其整机结构采用平板桁架式透明化设计，外形简约大方，能支持多种激光雷达，TK1、树莓派等主流控制器，可搭载assustion、Kinect1 、Kinect2等深度摄像头。Mini体型小、功能强大、性价比高，非常适合入门者开发研究和多机集群应用研究。效果如图: Stone是一款采用前万向后双驱动轮底盘布局的智能车平台。其整机结构采用平板桁架式透明化设计，外形简单又不失机械美感。Stone可搭载Dobot1、Dobot m1等小型机械臂，能支持多种激光雷达，TX1、TK1、树莓派等主流控制器。其配备高度可调的两轴云台，兼容多款RGBD摄像头和单、双目摄像头。效果如图: Giraffe是一款采用前万向后双驱动轮底盘布局的智能车平台。其整机结构采用平板桁架式封闭式设计；侧板采用带磁吸可开合设计；传动系统采用同步带传动。Giraffe可同时支持一前一后两个激光雷达，兼容TX1、TK1、树莓派等主流控制器，配备高度可调、能兼容多款RGBD摄像头和单、双目摄像头的两轴云台。Giraffe可搭载HandsFree中型机械臂（重量15Kg左右），具有高达65Kg的承载能力。效果如图: Turtlebot 英文是介绍的原文,中文下面中文进行了简要的翻译 TurtleBot is a low-cost, personal robot kit with open-source software. TurtleBot was created at Willow Garage by Melonee Wise and Tully Foote in November 2010. With TurtleBot, you’ll be able to build a robot that can drive around your house, see in 3D, and have enough horsepower to create exciting applications.The TurtleBot kit consists of a mobile base, 2D/3D distance sensor, laptop computer or SBC(Single Board Computer), and the TurtleBot mounting hardware kit. In addition to the TurtleBot kit, users can download the TurtleBot SDK from the ROS wiki. TurtleBot is designed to be easy to buy, build, and assemble, using off the shelf consumer products and parts that easily can be created from standard materials. As an entry level mobile robotics platform, TurtleBot has many of the same capabilities of the company’s larger robotics platforms, like PR2.Turtlebot是一种低成本，具有开源开源软件的个人机器人开发套件。利用Turtlebot，你将能够建立一个可以驱动你的房子周围的机器人，看3D视图，并有足够的马力，并创造令人兴奋的应用。Turtlebot开发套件由一个移动底盘，二维/三维距离传感器、笔记本电脑或SBC（单板计算机），和turtlebot安装硬件套件组成。还有,对turtlebot套件来说，用户可以从ROS的wiki上下载Turtlebot SDK。Turtlebot设计易于购买，建造，安装，使用现成的消费产品和零件，很容易可以从标准的材料制造。作为一款入门级的移动机器人平台，Turtlebot有许多的公司更大的机器人平台相同的功能，比如PR2机器人。 下面简要介绍一下机器人,Turtlebot现存的机器人有第二代和第三代的机器人,这两代机器人差别比较大.Turtlebot2是一个系列,大部分都是由Kobuki移动底盘,华硕的Xtion深度摄像头/kinect深度摄像头,一个可以上网的笔记本,还有放置笔记本和kinect的各种结构,机器人.机器人主要的部分就是kobuki移动底盘,摄像头和可联网的PC.但是第二代机器人的移动底盘是封装好了的,内部机械及软件均是不开源的,只留下了更新固件接口及其他一些接口.因为不开源我们无法对其进行更多的分析,但不可否认的是,这个移动底盘确实比较稳定和准确.效果如图: Turtlebot3也是一个系列,现在主要的两款是Burger和Waffle.主要由树莓派,一块STM32F７电路板,还有雷达组成.有人尝试在上面加装深度摄像头和机械臂,但是感觉也只是装饰,由于高度的限制,只有雷达能够发挥出全部的作用.第三代机器人和第二代机器人来比较的话,变化非常大.(1)更加地低成本,选取的硬件都很low,有点面向高中生的意思,在上面计算怕是不行.(2),全部开源,第三代机器人的硬件软件全部是开源的,不像第二代,移动底盘是一个集成好了的产品.效果如图: 产品详细对比 因为Turtlebot2并不是全部开源,所以我们在对比的时候会将所知的Turtlebot2的信息提及,但是主要将对Turtlebot3和HandsFree举例进行比较. 机械 参数差异 机械方面,HandsFree有三款机器人,小型的Mini到大机器人Giraffe,不同规格满足不同需求.Turtlebot方面第二代产品与我们的中型产品Stone大小类似,第三代产品结构设计的不太合理，如果客户不手动加高，那么实际用起来效果和与Mini类似，下面是对比: 参数类型 Mini Stone Giraffe Turtlebot2 Burger Waffle 高度(mm) 320 1081 1502 124.8 192 141 直径(mm) 230 400 441/399 351.5 140/180 280/306 重量(kg) 2 8 20 5 1 1.8 负载能力(kg) 6 15 65 5 15 30 最大速度(m/s) 1.2 1.2 2 0.7 0.22 0.26 说明分析 机械结构来说,HandsFree占据更多优势. 高度,要知道,所有的深度摄像头都有一个盲区,比如说Xtion2的有效距离是0.8~3.5m,但是Turtlebot3高度太低,会有很大的盲区.HandsFree每款机器人都有架高了的云台,视野更好. 速度,由于较好的稳定性,HandsFree的速度都要比Turtlebot要快 承载能力方面,相差不是特别大,而且如果是加装机械臂的话,感觉Turtlebot3底盘实在是太低了.Handsfree其中两款都可以加装机械臂,位置也比较合适. 云台,Turtlebot所有系列都没有云台,而HandsFree所有的机器人都可以加装云台,可以使视野更广. 主控制器 参数介绍 HandsFree中Mini机器人用的控制器是OpenRE Board Mini,另外两款使用的是OpenRE Board,这两款软硬件全部开源.Turtlebot2底盘控制是个黑箱子,既不能自己拓展应用又不能自主开发,很赚钱,毕竟人家是专业的靠这个吃饭的,做出来的控制效果和里程计的精确度可能会比较高,但是没有参数,我们并不能进行比较,但是Turtlebot3是全部开源的,我们可以拿来比较一下． 从下面的比较可以看出，Turtlebot3的控制器也就是用了一片stm32F7，其它的整体来看，板子还是挺低端的，接口也是各种排针，不适合专业的机器人系统，和OpenRE Board比起来还是差了许多． OpenRE Board 主要特征: 168MHZ STM32F407 Cortex M4 板载三轴陀螺仪，三轴加速计，气压计，三轴磁力计。 10PWM输入输出。 USBTTL, USB，microSD卡。 支持机型： 两轮平衡车，两轮差移动平台，三轮全向平台，四轮差速平台，四轮麦克纳姆轮全向平台，数字舵机人形，固定翼，四六八轴旋翼飞行器等。 细节看下图,可以在链接中查看更多细节. Turtlebot3使用的是基于STM32F7开发的开发板,MCU不错,板子整体资源太少: 我顺便把Mini的参数放上去吧: 说明分析 Turtlebot2的底盘控制器可能比我们的要好,已知的只有防撞传感器,红外传感器,防跌落传感器,110度/s单轴陀螺仪. HandsFree 控制器，板载资源十分丰富，下料十足，可满足常见形态机器人研究需求，同时不惜成本，尽量选择稳定可靠的接口和IC，光是一个ADC基准电压的芯片就十几块钱，MOLEX接口也是选用昂贵的自锁接口，这主要是因为 HandsFree 团队本身也是使用这款控制器进行研究开发的，所以在很多细节方面考虑也是为了满足自己需求。同时HandsFree团队为该控制器开发了OpenRE嵌入式机器人库，用户可以方便的在此库的基础上进行应用程序构建。而且OpenRE是还可以完全支持在linux环境下开发，这大大方便了ROS开发者和不懂嵌入式的机器人开发者。 Turtlebot3的MCU比较高端,但是开发板上的资源倒是有限,感觉有点浪费了,板载接口也是排帧，T插，很不便于开发． 总结:Turtlebot3板载资源只能跟Mini稍微比较一下,和HandsFree第二代上的板载资源完全没有比较性.Kobuki底盘控制器参数未知,程序也不是开源的,无法进行比较,只能说可能有一定优势. 电源供电方案 参数介绍 Power Manager 是HandsFree 开源项目的硬件标准设计的一款电源分配板，附带多路开关和多种电源转换功能，满足机器人多样的电力需求。 支持常用的 TX1， TK1， MiniPC，树莓派， Kinect ，HOKUYOU 雷达等设备供电，同时还支持机器人的电机驱动， 云台舵机，机械臂等结构的供电，还自带一个急停开关接口和 一路急停电源输出。配合大容量电池可以为机器提供集成供电方案。 HandsFree移动平台上采用集成化的供电方案，这是为了简化机器人开发者对电源的设计同时方便开发者进行多种形式的开发。在电源板上有数量众多的电源接口，提供多种不同的电压，可以给各种形式的设备进行供电。同时我们定义了不同接口的所代表的不同电压，保证了不同的电压的设备和接口不能顺利连接在一起，从而保护设备。 整个电源管理系统是HandsFree机器人的一个优点，这也是Turtlebot3所没有考虑到的． Turtlebot2移动底盘有对外的接口,内置电池,Turtlebot3也设置了对外接口.下面是二者的对比: 参数类型 Mini Stone Giraffe Turtlebot2 Burger Waffle 是否涵盖电源管理 有 有 有 未知 无 无 电源扩展 12V/3A x 2 , USB5V/2A x 2 19V/3A x 3 , 12V/10A x 5 12V/3A x 4 , USB5V/2A x 2 一路急停12V/10A 24V/30A x 5 , 19V/3A x 3 12V/3A x 4 , USB5V/2A x 2 一路急停12V/30A 12V/5A 12V/1.5A 5V/1A 3.3V/0.8A 5V/4A 12V/1A 3.3V/0.8A 5V/4A 12V/1A 支持外接设备 RplidarA1/A2 Hokuyo URG-04L/UTM-30Lx Xtion1/2，Kinect1/2 TK1，树莓派，工控机 Mini支持的设备 + ZED Camera , Dobot机械臂 1/2 Stone支持的设备 + HandsFree机械臂 参考上述电源接口 参考上述电源接口 参考上述电源接口 电源电压和容量　 12v/5200mAh 12V 16000mAh 24V 20000mAh 12v/2200mAh　　/4400mAh 12v/1800mAh 12v/1800mAh 续航时间（h） 8 12 12 ? 2.5 2 说明分析 无论是在电池管理，电池容量和接口方面,HandsFree都相对更加优秀.HandsFree提供了专门的电源模块,支持的可搭载模块更多，并且都集成在电源管理板上． 电机,驱动 HandsFree Motor Drive V2 是HandsFree Team根据Hands Free开源项目的标准开发的一款电机驱动器，是HandsFree开发的机器人Stone的硬件的组成部分之一。每块驱动板使用两块BTS7970芯片，可以驱动一个电机，保证足够大的驱动能力。同时能够将电源转接给其他驱动，极大的减少驱动电源线连接的复杂程度。 Turtlebot2驱动电机均未知.Turtlebot3使用Dynamixel X series;Burger电机为DYNAMIXEL (XL430-W250-T),Waffle电机为DYNAMIXEL (XM430-W210-T). 感觉这方面半斤八两吧. 下位机软件 Turtlebot2不是开源的,所以没有第二代的资料,也就是说第二代底层是不支持二次开发的.Turtlebot3下位机软件为OpenCR,开发工具为Arduino的IDE. 具体代码没有研读,不过考虑到主控板上资源较少,就算进行二次开发也很受限制，Arduino的IDE相信用过的人也该吐槽了． HandsFree下位机软件为OpenRE. OpenRE全称Open Source Robot Embedded Library，是一个专门为机器人写的、基于STM32系列微处理器的嵌入式开源库。经过不断优化，开源库变得鲁棒和通用，从而独立于平台成为一个专门为机器人而生的一个嵌入式库。主要目的是搭建一个专门为机器人服务的嵌入式跨平台软件框架，涵盖底层设备驱动，算法库，通信与操作系统组件等，主要涵盖以下内容： OpenRE的代码由底层到上层主要分为底层接口函数库、常用外设驱动库、OS库、机器人对象的抽象库、第三方库的移植等。 底层接口函数库：在官方固件库的基础上，将对GPIO、定时器、编码器、USART、CAN、IIC、SPI、ADC和PWM等底层资源的操作进一步进行封装。 常用外设和传感器驱动库：对常用的外设提供驱动，例如电机控制、舵机控制、LCD屏幕驱动、航模遥控器的解码，加速计，陀螺仪，磁力计，超声，红外，GPS解码，EEPROM，SD卡驱动等。 OS库：开发的应用程序包含裸跑程序版本和有操作系统版本，OpenRE移植了实时操作系统（ RTOS），图形库（GUI），网络协议（LWIP）， USB 协议，使用者可以根据自己的需求，选择合适的模板进行开发，省去了移植过程的繁琐操作． 模型和算法库：对移动底盘模型的抽象，包括差分底盘、4轮麦轮底盘和3轮全向轮底盘的运劢学模型，机器人运动坐标变换，卡尔曼滤波，四元数，矩阵运算，PID控制包等 第三方库的移植：移植的第三方库，包括Dobot机械臂库，Eigen3和Matrix矩阵库。 OpenRE支持Windows 和 Linux开发环境，方便了机器人开发人对系统的需求，支持Linux环境下的makefile + QTCreator + armgcc来进行开发 获取OpenRE源码： OpenRE Github OpenRE开发教程：OpenRE Tutorial ROS和上位机 ROS(Robot Operating System)是一个开源的平台,也是一个提供各种库文件帮助软件开发人员创建机器人应用程序的工具。它提供了硬件抽象层、设备驱动程序、库、可视化工具、消息传递、包管理，还有更多其他的。Turtlebot和HandsFree上层都是基于ROS进行开发,由于ROS的开源的性质,在上位机软件方面两类机器人差别不大,都可以使用ROS库进行开发,Turtlebot的Demo和HandsFree的Demo都是大同小异,大部分程序也是相通，甚至可以互相支持.所以,在这方面,二者没区别. 总结:　Turtlebot第三代开发受限制很多,总体来说不如HandsFree的开源的下位机软件. 销售及服务对比 价格 价格方面也是碾压趋势,HandsFree三款机器人分别对应不同群体,价格区间在2000-10000不止,套餐选择很人性化.Turtlebot系列,第三代价格在6500左右,第二代只要光是底盘就4500,更不要说上面要架设kinect和笔记本了. 参数类型 Mini Stone Giraffe Turtlebot2 Burger Waffle 价格(RMB) 1998/35984398/5398 5998/8598/1039812398/15398 12998/2099824598/66998 11399 5500 15500 说明: 价格一栏格式为:基础版/导航版/视觉开发版 教程 因为两家机器人都是基于ROS,国内也有在推广ROS的各种组织,所以关于ROS方面的资料都可以找到.TurtleBot系列和HandsFree系列都提供较为完整的学习指导和培训，在GitHub上提供开源的代码供客户学习使用，有自己的讨论社区为广大机器人爱好者提供讨论分享，碰撞思维的平台。 Turtlebot系列的其他资料都以Wiki的形式给出,大部分资料都可以在官网找到. HandsFree的资料也是依靠gitbook整理形成的Wiki,所有资料都可以在里面找到.不仅如此，HandsFree建设有交流社区,社区交流群: 521037187 (Hands Free Community) ,群内大部分都是HandsFree使用者及开发者,大家可以互相学习解惑. 其他 HandsFree相对Turtlebot有天然的优势,一堵无形的墙.我们产品如果有什么问题,社区提问,或者直接找到我们公司很方便. 有二十多所大学的实验室,使用了HandsFree平台作为研发平台 十几个创业公司使用了HandsFree作为原型机 软件框架更是被众多机器人爱好者所使用 HandsFree　搭建了自己的网站,交流社区,淘宝店,Github等,希望能帮助更多机器人开发者. 总结 硬件方面,由于Turtlebot2的不开放我们无法进行比较,但是通过与Turtlebot3的对比,我们发现资本主义都是纸老虎.不能说全面碾压Turtlebot3,但是可以说占据很大的优势了. 软件方面,同是支持ROS开发的机器人,ROS的驱动算法一类的又都是开源的,这方面差别不大,但是Handsfree仍然占据了高地,HandsFree的OpenRE代码更加专业，解析详细,支持的编译工具更多,支持Linux环境下的makefile + QTCreator + armgcc来进行开发,更地满足了程序员的需求. 销售方面,我们搭配的套餐更加人性化,质量高,价钱低.服务与Turtlebot不相上下,我们还提供了大家互相交流的社区,以及及时方便的售后. 综上所述,HandsFree相对Turtlebot3,具备了肉眼可见的优势． Copyright © 深圳朝闻道智能信息科技有限公司 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-06-02 16:12:07 "},"docs/Tutorial/":{"url":"docs/Tutorial/","title":"初级教程","keywords":"","body":"初级教程 本节教程旨在帮助用户成功地安装、使用和开发HandsFree机器人。机器人上主要用到的软件是基于ROS的，请访问www.ros.org了解ROS。 视频教程列表(持续更新) 第一讲: HandsFree机器人系统安装和环境配置。视频地址 第二讲: HandsFree机器人遥控，建图，自主导航。视频地址 网页教程简介 本章将介绍HandsFree机器人的初级教程,主要包括了 准备开始,这部分我们将介绍如何使用机器人端工控机（或PC）对机器人进行控制。通过控制机器人的测试，我们可以验证工控机的ROS环境和HandsFree的环境是否配置正确、机器人嵌入式系统是否工作正常、机器人嵌入式系统层和PC端ROS层的通讯是否正常等问题。 遥控机器人,先前我们介绍了如何使用工控机控制机器人,本节将介绍了如何使用自己的电脑对机器人进行遥控。通过使用远程计算机对机器人进行控制，我们可以验证远程计算机ROS环境和HandsFree的环境是否配置正确，机器人端工控机和远程计算机通讯是否正常等问题。 雷达建图,本节演示了如何使用雷达进行同步建图与定位，又称SLAM。SLAM问题可以描述为：机器人在未知环境中从一个未知位置开始移动,在移动过程中根据位置估计和地图进行自身定位,同时在自身定位的基础上建造增量式地图。这是导航部分的基础。 自主导航,本节利用上一节所建地图,进行了自主导航的实验。自主导航系统是机器人的重要组成部分，它能够提供给机器人正确的路径规划和姿态信息，从而使机器人能在一定的环境进行工作，完成指定任务，也是机器人实现路径规划，避障避碰，智能自主控制的基础。 RGBD摄像头实验,本节介绍了RGBD摄像头的环境配置和图片信息实时获取的方法,并且介绍了一种使用RGBD模拟二维雷达进行同步定位与建图的方法。 视觉实验,在上一节介绍了摄像头的简单使用,这一节我们将利用RGBD和计算机视觉方法实现机器人对二维码的跟随。 云台跟踪实验,机器人的头部是由二自由度云台构成，Xtion置于云台上，可以进行俯仰和偏转运动。本节是结合计算机视觉,实现云台对二维码的跟踪。 仿真实验,Gazebo是一个功能十分强大的三维仿真软件，与ROS可以无缝连接进行机器人仿真。我们提供了HandsFree机器人在Gazebo中的模型,本节介绍了如何简单使用Gazebo。 RGBDSLAM v2实验,rgbdslam v2是2014年提出的一种优秀的slam算法,它整合了SLAM领域里的各种技术：图像特征、回环检测、点云、图优化等等，是一个非常全面且优秀的程序。我们将在这部分介绍rgbdslam v2在handsfree机器人上的使用。 ORB_SLAM2 实验,orb-slam是15年出的一个单目SLAM,是一个比较优秀的系统,后来作者又推出了orb-slam2,在原来基础上增加了双目和rgbd的接口.我们将介绍orb-slam2在HandsFree在机器人上的使用. Copyright © 深圳朝闻道智能信息科技有限公司 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-09-14 19:37:01 "},"docs/Tutorial/1.1-Getting-Started.html":{"url":"docs/Tutorial/1.1-Getting-Started.html","title":"准备开始","keywords":"","body":"准备开始 这部分我们将介绍如何使用机器人端工控机（或PC）对机器人进行控制。通过控制机器人的测试，我们可以验证工控机的ROS环境和HandsFree的环境是否配置正确、机器人嵌入式系统是否工作正常、机器人嵌入式系统层和PC端ROS层的通讯是否正常等问题。 第一讲: HandsFree机器人系统安装和环境配置。视频地址 工控机环境配置 如果购买了我们的工控机,那么系统环境都已经配置完成，请略过这一步。 如果使用自己的工控机或者使用笔记本电脑替代我们提供的工控机,我们提供了两种方案配置工控机（PC） 1,安装我们提供的镜像，请参考如何使用镜像 2,按照环境配置教程配置HandsFree运行需要的环境 注意:安装镜像时,用户名和密码都是： handsfree Tips： 下一步操作前请确认HandsFree的环境变量。 gedit .bashrc 找到环境变量**HANDSFREE_ROBOT_MODEL** 把HANDSFREE_ROBOT_MODEL设置成你的机器人模型，2018.8月以后买到的stone为stone_v3，8月之前的为stone_v2. 启动机器人 将工控机的USB口和机器人的航空插座通过USB转航空插头的线将两者相连，连接屏幕与键鼠，然后连接工控机与电源，最后上电，开机。此时可以听到主控的一声蜂鸣器鸣叫声。确保工控机与机器人连接正常、工控机开机正常。然后开始下一步操作。 启动机器人抽象节点 在工控机上打开一个终端，并运行： roslaunch handsfree_hw handsfree_hw.launch 正常情况下，会显示： started core service [/rosout] process[handsfree_hw_node-2]: started with pid [7400] process[mobile_base/controller_spawner-3]: started with pid [7405] process[robot_state_publisher-4]: started with pid [7408] the configure file path is: /home/kedou/ros_workspace/mobile_robot_ws/src/handsfree/handsfree_hw/config.txt transport initialize ready config file opened succeed [INFO] [WallTime: 1527575549.385475] Controller Spawner: Waiting for service controller_manager/load_controller [INFO] [WallTime: 1527575549.388362] Controller Spawner: Waiting for service controller_manager/switch_controller [INFO] [WallTime: 1527575549.391300] Controller Spawner: Waiting for service controller_manager/unload_controller [INFO] [WallTime: 1527575549.395222] Loading controller: joint_state_controller [INFO] [WallTime: 1527575549.413541] Loading controller: pitch_position_controller [INFO] [WallTime: 1527575549.453398] Loading controller: yaw_position_controller [INFO] [WallTime: 1527575549.483493] Loading controller: mobile_base_controller [INFO] [WallTime: 1527575549.523318] Controller Spawner: Loaded controllers: joint_state_controller, pitch_position_controller, yaw_position_controller, mobile_base_controller [INFO] [WallTime: 1527575549.536325] Started controllers: joint_state_controller, pitch_position_controller, yaw_position_controller, mobile_base_controller 该条命令打开了机器人抽象节点，该节点的作用是完成PC与机器人底层的通讯和相关指令与数据传输。运行结果如上图，若出现timeout的问题，则说明该节点运行不成功。失败请参考常见问题及解答。 当这一步没有问题时，说明硬件方面正常，可以进行下一步了。 打开控制节点 打开一个新的终端，并运行： roslaunch handsfree_hw keyboard_teleop.launch 正常情况下，会显示： ROS_MASTER_URI=http://Robot:11311 core service [/rosout] found process[turtlebot_teleop_keyboard-1]: started with pid [9903] Control Your Turtlebot! --------------------------- Moving around: u i o j k l m , . q/z : increase/decrease max speeds by 10% w/x : increase/decrease only linear speed by 10% e/c : increase/decrease only angular speed by 10% space key, k : force stop anything else : stop smoothly CTRL-C to quit currently: speed 0.2 turn 1 该条命令打开键盘控制节点，按照终端中的提示，我们就可以利用键盘控制机器人运动。如果一切正常的话，你可以和移动ROS小乌龟一样，用键盘控制移动底盘运动了。到此，完成ROS控制机器人功能的实现，如果一切正常的话，说明移动底盘的软硬件没有问题，ROS端机器人抽象节点也没有问题。但是由于工控机在机器人上，我们只能跟着机器人跑来跑去。不用担心，我们马上在下个教程就能实现远程遥控机器人这个功能。 Copyright © 深圳朝闻道智能信息科技有限公司 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-09-14 19:37:48 "},"docs/Tutorial/1.2-First-Experiment.html":{"url":"docs/Tutorial/1.2-First-Experiment.html","title":"远程遥控机器人","keywords":"","body":"远程遥控机器人 什么是远程，为什么需要远程？ 远程指的是用远程的计算机来控制机器人，在HandsFree　Stone_v2版本和之前的机器人都没有搭载显示屏，不方面交互，这时候可以使用远程PC来和机器人上的PC共同控制机器人。 HandsFree　Stone_v3和之后版本的机器人已经搭载了显示屏，相对方面很多，不过远程功能在很多时候依旧方便开发，所以，学好远程功能的使用十分必要。 上一个教程中，我们利用机器人端的工控机实现了对机器人的控制。这一节我们将通过远程计算机对机器人进行控制，我们还可以验证远程计算机配置的ROS环境和HandsFree的环境是否配置正确，机器人端工控机和远程计算机通讯是否正常等问题。 远程计算机环境配置 远程计算机的系统版本和ROS版本必须和机器人上的工控机一致，否则会出现版本不统一的通信问题。 Stone V2和之前的机器人默认安装Ubuntu 14.04, Stone V3和之后的版本默认安装16.04, 然后按照环境配置教程配置HandsFree运行需要的环境，如果是在虚拟机中安装则设置网络为桥接模式 工控机与远程计算机通信 打开机器人身上的工控机和用户手上远程计算机 步骤如下: 1 使工控机和笔记本电脑必须处于同一局域网下(手机热点也行) 2 然后获取工控机的IP,获取IP方法请参照常见问题及解答 3 在远程计算机终端中登录工控机,@后面是工控机的IP地址 ssh -X handsfree@192.186.x.x 输入密码并登录成功后会显示大致如下结果: Welcome to Ubuntu 14.04.5 LTS (GNU/Linux 4.4.0-31-generic x86_64) * Documentation: https://help.ubuntu.com/ Last login: Tue Jan 30 21:36:25 2018 from 10.13.61.17 4 在工控机端，使用同样的方法，登录到远程计算机 ssh -X user_name@192.186.y.y 如果也没有错误产生，说明二者可以正常通信，可以进行下一步 远程设置 上一步中，我们已经可以通过局域网互相访问，那么只需要进行下面的设置，ROS程序就可以在工控机和远程计算机上分别运行。遥控机器人就是通过机器人抽象节点在机器人端的工控机上运行，遥控节点在远程计算机上运行来实现的。 Tips : IP_OF_ROBOT_PC 是工控机的IP，IP_OF_REMOTE_PC是远程计算机的IP。 在远程计算机中添加下面两行到~/.bashrc文件 export ROS_MASTER_URI=http://IP_OF_ROBOT_PC:11311 export ROS_HOSTNAME=IP_OF_REMOTE_PC 在机器人端工控机上添加下面两行到~/.bashrc文件，如图中最后两行所示 export ROS_MASTER_URI=http://IP_OF_ROBOT_PC:11311 export ROS_HOSTNAME=IP_OF_ROBOT_PC 远程遥控机器人 1 启动机器人 将工控机的USB口和机器人的航空插座通过USB转航空插头的线将两者相连，然后给机器人上电。此时可以听到主控的一声蜂鸣器鸣叫声。确保工控机与机器人连接正常，然后开始下一步操作。 2 启动机器人抽象节点在机器人端工控机上打开一个终端，并运行： roslaunch handsfree_hw handsfree_hw.launch 正常情况下，会显示： auto-starting new master process[master]: started with pid [9562] ROS_MASTER_URI=http://Robot:11311 setting /run_id to ffa41cce-05bd-11e8-8df0-001e64f02337 process[rosout-1]: started with pid [9575] started core service [/rosout] process[handsfree_hw_node-2]: started with pid [9585] process[mobile_base/controller_spawner-3]: started with pid [9589] process[robot_state_publisher-4]: started with pid [9591] [ERROR] [1517317423.863958024]: hf link initialized failed, please check the hardware [INFO] [WallTime: 1517317424.295263] Controller Spawner: Waiting for service controller_manager/load_controller [INFO] [WallTime: 1517317424.298319] Controller Spawner: Waiting for service controller_manager/switch_controller [INFO] [WallTime: 1517317424.301498] Controller Spawner: Waiting for service controller_manager/unload_controller [INFO] [WallTime: 1517317424.304670] Loading controller: joint_state_controller [INFO] [WallTime: 1517317424.351596] Loading controller: servo1_position_controller [INFO] [WallTime: 1517317424.399306] Loading controller: servo2_position_controller [INFO] [WallTime: 1517317424.419282] Loading controller: mobile_base_controller [INFO] [WallTime: 1517317424.469234] Controller Spawner: Loaded controllers: joint_state_controller, servo1_position_controller, servo2_position_controller, mobile_base_controller [INFO] [WallTime: 1517317424.479183] Started controllers: joint_state_controller, servo1_position_controller, servo2_position_controller, mobile_base_controller 该条命令打开了机器人抽象节点，该节点的作用是完成PC与机器人底层的通讯和相关指令与数据传输。运行结果如上图，若出现timeout的问题，则说明该节点运行不成功。失败请参考常见问题及解答。 3 打开遥控节点在远程计算机打开一个终端，并运行： roslaunch handsfree_hw keyboard_teleop.launch 正常情况下，会显示： ROS_MASTER_URI=http://Robot:11311 core service [/rosout] found process[turtlebot_teleop_keyboard-1]: started with pid [9903] Control Your Turtlebot! --------------------------- Moving around: u i o j k l m , . q/z : increase/decrease max speeds by 10% w/x : increase/decrease only linear speed by 10% e/c : increase/decrease only angular speed by 10% space key, k : force stop anything else : stop smoothly CTRL-C to quit currently: speed 0.2 turn 1 该条命令打开键盘控制节点，按照终端中的提示，我们就可以利用键盘控制机器人运动。如果一切正常的话，就表示我们就可以在远程计算机上共享机器人端工控机上ROS的信息了。到此，完成ROS控制机器人功能的实现，如果一切正常的话，说明远程计算机设置没有问题，与机器人的通信也没有问题，接下来就可以进行更高级功能的测试了。 远程的其它介绍 如果只是为了遥控，只用ssh就够了，ROS的远程是把两台PC的通信连接起来，所有topic可以在两台PC同时操作，更常用的是，我们可以把rviz，rqt等ros工具运行在远程计算机上，把算法运行在工控机上。 Copyright © 深圳朝闻道智能信息科技有限公司 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-07-27 13:33:36 "},"docs/Tutorial/2.1-Mapping.html":{"url":"docs/Tutorial/2.1-Mapping.html","title":"雷达建图","keywords":"","body":" 第二讲: HandsFree机器人遥控，建图，自主导航。视频地址 在实现导航功能之前需要对当前环境进行建图，在所下载的HandsFree_ROS包中所包含的地图是我们实验室的地图。所以你需要首先对你所在的环境使用激光雷达构建2维地图。 本节教程运行节点主要包含机器人抽象节点、激光节点、建图节点、遥控节点和可视化工具RVIZ 雷达建图 由于工控机不能区分雷达和主控板,开机后,一定要先插主控板（单片机）的USB,再将雷达的USB连接到工控机。 然后在工控机上运行以下节点，如果没有购买显示屏，可以远程登录到工控机再执行以下步骤: 机器人抽象节点 roslaunch handsfree_hw handsfree_hw.launch 激光节点 如果使用rplidar： roslaunch rplidar_ros rplidar.launch 若雷达正常，运行结果为： ROS_MASTER_URI=http://Robot:11311 core service [/rosout] found process[rplidarNode-1]: started with pid [13154] RPLIDAR running on ROS package rplidar_ros SDK Version: 1.5.7 RPLIDAR S/N: E94F9DF1C3E39AC4C3E698F91998340D Firmware Ver: 1.22 Hardware Rev: 4 RPLidar health status : 0 如果使用hokuyo: roslaunch handsfree_bringup hokuyo.launch 建图节点 roslaunch rplidar_ros gmapping.launch 此节点最后若显示Registering First Scan,说明成功，结果如下图所示： ROS_MASTER_URI=http://Robot:11311 core service [/rosout] found process[slam_gmapping-1]: started with pid [4745] process[move_base_node-2]: started with pid [4746] [ INFO] [1517365860.923519401]: Laser is mounted upwards. -maxUrange 10 -maxUrange 7.99 -sigma 0.05 -kernelSize 1 -lstep 0.05 -lobsGain 3 -astep 0.05 -srr 0.01 -srt 0.02 -str 0.01 -stt 0.02 -linearUpdate 0.5 -angularUpdate 0.436 -resampleThreshold 0.5 -xmin -10 -xmax 10 -ymin -10 -ymax 10 -delta 0.05 -particles 80 [ INFO] [1517365860.928967235]: Initialization complete update frame 0 update ld=0 ad=0 Laser Pose= 0.2 0 0.00872684 m_count 0 Registering First Scan 打开RVIZ可视化工具 rosrun rviz rviz -d `rospack find handsfree_2dnav`/rviz/HANDSFREE_Robot.rviz rviz文件也可以手动配置，选择rviz软件界面的file -> open config,手动选择handsfree/handsfree_2dnav/rviz/ HANDSFREE_Robot.rviz文件作为其配置文件。如果正常的话，可以在RVIZ中看到机器人模型及激光雷达扫描到的可视化数据，然后进行下一步打开键盘遥控节点建图。 遥控节点 启动键盘遥控节点: roslaunch handsfree_hw keyboard_teleop.launch 利用键盘遥控机器人在准备导航的环境中缓慢移动，使RVIZ中显示的地图逐渐补全，直到将整个环境的地图建好为止。 当地图建好之后就要对地图进行保存。 保存地图 在终端中打开想要保存地图的文件夹（建议保存在handsfree_2dnav/map中） roscd handsfree_2dnav/map/ 运行保存地图的节点： rosrun map_server map_saver -f my_map -f 后面跟的是地图保存的名字，my_map名字可以按照自己的需求更改此命令将生成将生成.pgm和.yaml两个文件。到此，建图过程完成。最终生成的我们实验室的地图： 远程建图 建议远程设置(如果IP有变化,请及时更改),将工控机作为MASTER,在工控机上运行前三个节点,遥控和可视化部分可以在自己笔记本上运行。 Copyright © 深圳朝闻道智能信息科技有限公司 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-09-14 19:38:10 "},"docs/Tutorial/2.1-Navigation.html":{"url":"docs/Tutorial/2.1-Navigation.html","title":"自主导航","keywords":"","body":"自主导航 简介 在实现导航功能之前需要对当前环境进行建图，在所下载的HandsFree_ROS包中所包含的地图是我们实验室的地图。所以你需要首先对你所在的环境使用激光雷达构建2维地图。 请确保你的电脑都连上了机器人USB通信接口，机器人已经上电，急停开关打开。自主导航实验，请按照顺序运行以下节点。 机器人抽象节点 roslaunch handsfree_hw handsfree_hw.launch 激光节点 如果使用rplidar： roslaunch rplidar_ros rplidar.launch 如果使用hokuyo: roslaunch rplidar_ros hokuyo.launch 导航节点 在运行前先对handsfree/handsfree_2dnav/launch/move_base_amcl.launch文件中的地图路径参数进行修改： 将args=\"$(find handsfree_2dnav)/map/lab.yaml\"改为之前建好的地图的名称，保存更改。Tips:远程登录时\"ssh -X handsfree@XX.XX.\"有-X可以直接使用图形化编辑软件gedit进行编辑 打开终端运行导航节点： roslaunch handsfree_2dnav move_base_amcl.launch 运行结果将如下所示： ROS_MASTER_URI=http://taozi-CW65S:11311 core service [/rosout] found process[map_server-1]: started with pid [5842] process[amcl-2]: started with pid [5843] process[move_base_node-3]: started with pid [5844] [ INFO] [1517366100.857502124]: Requesting the map... [ INFO] [1517366100.861548693]: Received a 608 X 608 map @ 0.050 m/pix [ INFO] [1517366100.878470309]: Initializing likelihood field model; this can take some time on large maps... [ INFO] [1517366100.904504598]: Done initializing likelihood field model. [ INFO] [1517366101.403377628]: Using plugin \"static_layer\" [ INFO] [1517366101.443103603]: Requesting the map... [ INFO] [1517366101.654435948]: Resizing costmap to 608 X 608 at 0.050000 m/pix [ INFO] [1517366101.754267777]: Received a 608 X 608 map at 0.050000 m/pix [ INFO] [1517366101.765321329]: Using plugin \"obstacle_layer\" [ INFO] [1517366101.773442492]: Subscribed to Topics: scan [ INFO] [1517366101.870169425]: Using plugin \"inflation_layer\" [ERROR] [1517366101.914023959]: You must specify at least three points for the robot footprint, reverting to previous footprint. [ INFO] [1517366102.035081884]: Using plugin \"obstacle_layer\" [ INFO] [1517366102.064833744]: Subscribed to Topics: scan [ INFO] [1517366102.162505652]: Using plugin \"inflation_layer\" [ERROR] [1517366102.208362231]: You must specify at least three points for the robot footprint, reverting to previous footprint. [ INFO] [1517366102.312270125]: Created local_planner base_local_planner/TrajectoryPlannerROS [ WARN] [1517366102.333831658]: /move_base_node/TrajectoryPlannerROS/acc_lim_th should be acc_lim_theta, this param will be removed in J-turtle [ INFO] [1517366102.354552287]: Sim period is set to 0.14 [ WARN] [1517366102.383073267]: Trajectory Rollout planner initialized with param meter_scoring not set. Set it to true to make your settins robust against changes of costmap resolution. [ INFO] [1517366103.099663496]: Recovery behavior will clear layer obstacles [ INFO] [1517366103.146419402]: Recovery behavior will clear layer obstacles [ INFO] [1517366103.257528221]: odom received! 利用RVIZ可视化导航过程 rosrun rviz rviz -d `rospack find handsfree_2dnav`/rviz/HANDSFREE_Robot.rviz 如果正常的话，可以在RVIZ中看到机器人模型及激光雷达扫描到的可视化数据。并且Global Options中的Fixed Frame选择map 初始位置的标定 在RVIZ地图中看到的机器人位置可能并不是其当前的实际位置，为了机器人的自主定位和导航，我们需要为其手动标定其初始位置。使用RVIZ中的2D Pose Estimate手动标定其初始位姿，调整RVIZ中机器人的位置，让其尽量与实际位姿一致，然后导航节点会根据雷达信息对其位置进行估计。方法:先点击2D Pose Estimate,然后将鼠标移动到机器人在地图中的实际位置,摁住左键,调整好方向后松开。 自主导航 使用RVIZ中的2D Nav Goal功能为机器人指定导航的目标点。方法:点击2D Nav Goal,然后用鼠标指定一个地图上机器人可以到达的地方,如果一切正常的话，机器人将自主移动到所指定的目标点。 其他 本节教程运行节点主要包含机器人抽象节点、激光节点、导航节点和可视化工具RVIZ。建议设置好远程设置(如果工控机IP有变化,请及时更改),将工控机作为MASTER,在工控机上运行前三个节点,可视化部分可以在自己笔记本上运行。 Copyright © 深圳朝闻道智能信息科技有限公司 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-09-14 18:24:47 "},"docs/Tutorial/2.2-RGBD-Test.html":{"url":"docs/Tutorial/2.2-RGBD-Test.html","title":"RGBD摄像头实验","keywords":"","body":"RGBD摄像头实验 HandsFree支持多种摄像头,包括Xtion Pro,Xtion 2,Kinect 1等.本节教程为Xtion Pro及Xtion 2的配置使用教程,Kinect 1请参考其他教程。若使用HandsFree提供的工控机,则可以直接进行测试,若使用自己的PC,则需要先安装驱动。本节还将讲解如何使用Asus Xtion 2进行建图。在雷达建图章节建图时我们使用激光雷达扫描周围环境，提供距离数据从而生成地图。除了使用激光雷达进行建图，我们也可以使用深度摄像头模拟激光雷达进行建图。 配置环境 1) 安装驱动 sudo apt-get install libopenni2-dev libopenni2-0 ros-indigo-openni2-launch ros-indigo-openni2-camera 华硕Xtion1，或者乐视的Xtion，ROS自带驱动，如果使用的是华硕Xtion2，则按照以下步骤按照驱动: 2) 安装华硕Xtion2官方提供的驱动,可以点这里下载.解压缩之后: cd ASUS-Linux-x64-OpenNI2.2 sudo sh install.sh sudo cp ASUS/Xtion2/lib/libSenDuck.so /usr/lib/OpenNI2/Drivers/ 3) 因为Xtion 2对ubuntu usb3.0不太友好,所以我们要设置带宽才可以同时接收rgbd,所以需要做以下设置: sudo rmmod uvcvideo sudo modprobe uvcvideo quirks=640 这个设置在重启之后会失效,需要重新设置.建议将其加入开机启动项. 测试摄像头 如果安装了我们的镜像或者已经按照前面的步骤安装了我们的ROS驱动包和上面的驱动,则可以开始测试，因为Xtion 2对ubuntu USB 3.0的支持还不是特别好，所以需要将摄像头连接到USB 2.0上，然后执行下面的命令： roslaunch handsfree_camera view_xtion.launch 运行结果如下所示： ROS_MASTER_URI=http://Robot:11311 setting /run_id to b5ad0dc4-0630-11e8-8254-56847afe9799 process[rosout-1]: started with pid [9028] started core service [/rosout] process[camera/camera_nodelet_manager-2]: started with pid [9045] process[camera/driver-3]: started with pid [9046] process[camera/rgb_rectify_color-4]: started with pid [9047] process[camera/depth_rectify_depth-5]: started with pid [9048] process[camera/depth_metric_rect-6]: started with pid [9049] process[camera/depth_metric-7]: started with pid [9050] process[camera/depth_points-8]: started with pid [9051] process[camera/depth_registered_rectify_depth-9]: started with pid [9057] process[camera/points_xyzrgb_hw_registered-10]: started with pid [9062] process[camera/depth_registered_hw_metric_rect-11]: started with pid [9067] process[camera/depth_registered_metric-12]: started with pid [9078] process[camera_base_link-13]: started with pid [9080] process[camera_base_link1-14]: started with pid [9090] process[camera_base_link2-15]: started with pid [9092] process[camera_base_link3-16]: started with pid [9102] [ INFO] [1517366692.165227976]: Initializing nodelet with 4 worker threads. open device fail open rts video device fail Video Camera at /dev/video1 Detected Depth Camera at /dev/video2 Detected [ INFO] [1517366698.357743962]: Device \"5Voxel.com\" found. Creating IR stream Creating color stream Creating Depth stream v4l2_query_control: error 9, Bad file descriptor v4l2_query_control: error 9, Bad file descriptor v4l2_query_control: error 9, Bad file descriptor [ WARN] [1517366699.161181724]: Reconnect has been enabled, only one camera should be plugged into each bus 不用担心，这个err是正常的，可以忽略。 查看图片有两种方法,第一种在rqt中可以查看图像，在终端中运行'rqt'： 如果打开rqt之后,没有image_view,可以手动添加:在窗口上,Plugins -> Visualization -> Image View即可添加成功。如果想切换不同topic查看,可以在/camera/rgb/image/raw那个窗口进行不同图像的切换. 查看图片的第二种方法,在终端打开image_viewer rosrun image_view image_view image:=/camera/rgb/image_raw rosrun image_view image_view image:=/camera/depth/image_raw 若RGB图像和深度图像都可以正常显示，则Xtion 2节点工作正常，接下来进行建图。 RGBD 建图 使用深度摄像头建图和使用激光雷达进行建图的过程基本相同，只是将打开激光雷达节点更换为打开Xtion虚拟激光节点。关闭之前打开全部终端，运行以下相关命令如下： 1) 运行机器人抽象节点： roslaunch handsfree_hw handsfree_hw.launch 2) 运行Xtion虚拟激光节点 roslaunch handsfree_camera xtion.launch roslaunch handsfree_vision fake_laser_by_xtion.launch 运行结果和运行Xtion驱动节点时相同，但是此文件还将启动一个depthimage_to_laserscan的节点,发布虚拟激光数据,如果你使用的是kinect，那就吧以上launch中的“xtion”替换成“kinect”。 3) 运行建图节点： roslaunch handsfree_2dnav gmapping.launch 4) 利用RVIZ可视化建图过程 rosrun rviz rviz -d `rospack find handsfree_vision`/rviz/rgbd_fake_laser_gmapping_by_xtion.rviz 如果正常的话，可以在RVIZ中看到机器人模型及激光雷达扫描到的可视化数据。 5) 打开键盘控制节点： roslaunch handsfree_hw keyboard_teleop.launch 利用键盘遥控机器人在准备导航的环境中缓慢移动，使RVIZ中显示的地图逐渐补全，直到将整个环境的地图建好为止。当地图建好之后就要对地图进行保存。 6) 保存地图在你打算保存地图的目录运行下面的命令： rosrun map_server map_saver -f my_map 将生成两个文件.pgm和.yaml文件，建议将地图放在handsfree/handsfree_2dnav/map/目录下便于统一管理。到此，使用Xtion虚拟建图过程完成，之后可以使用保存的地图进行导航功能的实现。 Xtion虚拟激光与激光雷达建图的区别 Xtion虚拟激光扫描的角度相对较窄，Xtion一般在57°左右，而一般的激光雷达的扫描范围能达到240°甚至更大。 Copyright © 深圳朝闻道智能信息科技有限公司 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-09-14 18:28:44 "},"docs/Tutorial/2.3-Vision-Test.html":{"url":"docs/Tutorial/2.3-Vision-Test.html","title":"视觉实验","keywords":"","body":"视觉实验 在RGBD Test章节我们使用Xtion模拟激光雷达进行建图，在本章节将讲解使用Xtion和计算机视觉方法实现机器人跟踪二维码。本节内容建议都在工控机上运行。 机器人抽象节点 打开机器人抽象节点 roslaunch handsfree_hw handsfree_hw.launch 确保工控机及机器人底层连接正常,如果不能,请参考常见问题及解答进行解决。 摄像头驱动节点 打开Xtion驱动节点，将发布一系列RGB图像数据和深度图像数据： roslaunch handsfree_camera xtion.launch 二维码识别节点 使用RGB图像数据进行二维码识别： roslaunch handsfree_ar_tags ar_indiv_rgb_camera.launch 运行结果大致如下所示： ROS_MASTER_URI=http://Robot:11311 core service [/rosout] found process[ar_track_alvar-1]: started with pid [10310] [ WARN] [1517366973.387724985]: Command line arguments are deprecated. Consider using ROS parameters and remappings. [ INFO] [1517366973.392963280]: Subscribing to info topic [ INFO] [1517366973.460607649]: AR tracker reconfigured: ENABLED 10.00 6.60 0.08 0.05 [ INFO] [1517366974.469605297]: Subscribing to image topic 或者使用深度图像数据进行二维码识别： roslaunch handsfree_ar_tags ar_indiv_depth_camera.launch 上面两条命令二选一即可，它们都是使用开源的二维码识别库ar_track_alvar进行二维码的识别，ar_indiv_rgb_camera.launch和ar_indiv_depth_camera.launch文件的主要区别是订阅的话题不同，更多资料请参考ar_track_alvar的WIKI。 跟踪节点 运行二维码跟踪器。 roslaunch handsfree_ar_tags ar_follower.launch 运行结果将如下所示： ROS_MASTER_URI=http://Robot:11311 core service [/rosout] found process[ar_follower-1]: started with pid [10779] [INFO] [WallTime: 1517367066.348273] Waiting for ar_pose_marker topic... 将/handsfree/handsfree_ar_tags/config/Markers_0_2.png文件打印在纸上，将打印出的图案放置在Xtion摄像头前方，慢慢移动图案，机器人将跟随二维码图案位置的移动而运动。 Copyright © 深圳朝闻道智能信息科技有限公司 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-07-27 14:02:59 "},"docs/Tutorial/2.4-Head-Tracking.html":{"url":"docs/Tutorial/2.4-Head-Tracking.html","title":"云台跟踪实验","keywords":"","body":"云台跟踪实验 在视觉实验演示了如何控制机器人跟踪二维码，本章将讲解如何控制机器人的头部Xtion跟踪二维码。HandFree机器人的头部是由二自由度云台构成，Xtion置于云台上，可以进行俯仰和偏转运动。云台由两个模拟舵机组成，确保舵机已正确连接至主控。实现头部跟踪的过程与上一章节的过程类似。建议节点都在工控机上运行 机器人抽象节点 打开机器人抽象节点 roslaunch handsfree_hw handsfree_hw.launch 确保工控机及机器人底层连接正常,如果不能,请参考常见问题及解答进行解决。 摄像头驱动节点 打开Xtion驱动节点，将发布一系列RGB图像数据和深度图像数据。 roslaunch handsfree_camera xtion.launch 识别节点 使用RGB图像数据进行二维码识别： roslaunch handsfree_ar_tags ar_indiv_rgb_camera.launch 运行结果大致如下所示： ROS_MASTER_URI=http://Robot:11311 core service [/rosout] found process[ar_track_alvar-1]: started with pid [10310] [ WARN] [1517366973.387724985]: Command line arguments are deprecated. Consider using ROS parameters and remappings. [ INFO] [1517366973.392963280]: Subscribing to info topic [ INFO] [1517366973.460607649]: AR tracker reconfigured: ENABLED 10.00 6.60 0.08 0.05 [ INFO] [1517366974.469605297]: Subscribing to image topic 或者使用深度图像数据进行二维码识别： roslaunch handsfree_ar_tags ar_indiv_depth_camera.launch 上面两条命令二选一即可，它们都是使用开源的二维码识别库进行二维码的识别，ar_indiv_rgb_camera.launch和ar_indiv_depth_camera.launch的区别主要是订阅的话题不同，更多资料请参考ar_track_alvar的WIKI。 头部跟踪节点 运行头部跟踪器。 rosrun handsfree_ar_tags head_tracker.py 将/handsfree/handsfree_ar_tags/config/Markers_0_2.png文件打印在纸上，将打印出的图案放置在Xtion摄像头前方，慢慢移动图案，机器人的头部将跟随二维码图案位置的移动而运动。 Copyright © 深圳朝闻道智能信息科技有限公司 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-07-27 14:25:29 "},"docs/Tutorial/3.1-Simulation.html":{"url":"docs/Tutorial/3.1-Simulation.html","title":"仿真实验","keywords":"","body":"仿真实验 Gazebo是一个功能十分强大的三维仿真软件，与ROS可以无缝连接进行机器人仿真。更多关于Gazebo的信息请参考Gazebo官网和ROS官网的Gazebo Wiki。本章讲解如何控制HandsFree的机器人模型在Gazebo的三维世界中进行移动。 在安装ROS的时候一般已经默认安装了Gazebo，ROS Indigo默认安装Gazebo2.0版本，ROS Kinetic默认安装Gazebo7.0版本。在如何配置环境章节已经安装了连接ROS与Gazebo的依赖包。通过以下命令测试Gazebo是否能正常工作： roslaunch gazebo_ros empty_world.launch 如果能正常启动Gazebo，并且可以成功加载一个空白的世界模型，那就表示Gazebo可以正常工作。正常加载empty_world模型：此外，Gazebo对电脑显卡有一定要求，对Nvida显卡支持较好，对AMD的显卡支持较差，如果是AMD的显卡，复杂的世界模型一般加载不出来，例如下面的模型： roslaunch gazebo_ros willowgarage_world.launch 一般AMD的显卡可以启动Gazebo，但是界面是黑屏状态，无法加载模型。由于本章节的演示所加载的模型较简单，故对本章节要进行的仿真演示没有影响。下面进入正文。 测试Gazebo 使用如下命令打开Gazebo并加载HandsFree的机器人模型： roslaunch handsfree_gazebo demo_gazebo_stone_v3.launch 如果一切正常的话，可以在Gazebo的世界中看到HandsFree的Stone机器人模型。 遥控机器人 打开一个新的终端，并运行： roslaunch handsfree_hw keyboard_teleop.launch 操作方式和前几节一致。 自主导航测试 关闭掉遥控终端，运行自主导航节点 roslaunch handsfree_gazebo demo_move_base_amcl.launch 然后就可以按照前几节讲的自主导航在RVIZ上发送目标点。 Copyright © 深圳朝闻道智能信息科技有限公司 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-07-27 21:25:13 "},"docs/Tutorial/RGBDSLAMV2.html":{"url":"docs/Tutorial/RGBDSLAMV2.html","title":"RGBDSLAM v2实验","keywords":"","body":"RGBD SLAM v2实验 这次跑得是视觉SLAM的经典程序:RGBD SLAM V2,本实验是一个比较经典的实验,可以建成一个稠密三维点云。所用摄像头是Xtion 2。 环境配置 前提仍然是ubuntu14.04,ROS用的是indigo,所以在下载程序的时候,我下载的是indigo版本,也就是在github上选择branch,换成indigo,在github 上查看如何安装,或者直接在终端执行下面的命令: //创建工作空间 source /opt/ros/indigo/setup.bash mkdir -p ~/rgbdslam_catkin_ws/src cd ~/rgbdslam_catkin_ws/src catkin_init_workspace cd ~/rgbdslam_catkin_ws/ catkin_make echo \"~/rgbdslam_catkin_ws/devel/setup.bash\" //下载源码 cd ~/rgbdslam_catkin_ws/src wget -q http://github.com/felixendres/rgbdslam_v2/archive/indigo.zip unzip -q indigo.zip cd ~/rgbdslam_catkin_ws/ //安装 rosdep update rosdep install rgbdslam catkin_make 测试程序 使用下面命令测试rgbdslam是否安装成功： roslaunch rgbdslam rgbdslam.launch 如果程序运行成功，则可以开始进行第三步，三维建图实验。 运行程序 直接roslaunch官方包中的launch是不行的,图片信息和没有对应上,还有摄像头的某个服务没有开启,rgbdslam这个节点接受不到照片信息。所以我们对文件进行了改动,并放在了handsfree_bringup中,所以,请先启动摄像头 roslaunch handsfree_bringup openni_slam.launch 然后启动RGBDSLAM v2的GUI界面 roslaunch handsfree_bringup rgbdslam_v2.launch 如果程序如上图所示，则说明程序运行良好，由于比较消耗资源，电脑可能会变卡。可以摁空格暂停查看点云,也可以在全屏之后的上端菜单栏选择需要保存的信息。 Copyright © 深圳朝闻道智能信息科技有限公司 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-06-02 16:12:07 "},"docs/Tutorial/ORBSLAM2.html":{"url":"docs/Tutorial/ORBSLAM2.html","title":"ORB_SLAM2 实验","keywords":"","body":"Copyright © 深圳朝闻道智能信息科技有限公司 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-06-02 16:12:07 "},"docs/Tutorial/Advanced/":{"url":"docs/Tutorial/Advanced/","title":"进阶教程","keywords":"","body":"Tutorial Copyright © 深圳朝闻道智能信息科技有限公司 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-06-02 16:12:07 "},"docs/Tutorial/Advanced/Behavior-Tree/":{"url":"docs/Tutorial/Advanced/Behavior-Tree/","title":"行为树","keywords":"","body":"行为树 这部分我们将以python smach框架为基础讲解机器人行为树，通过这部分的学习，您将了解到3种常用机器人行为树写法 --- 串行、并发于同步、抢占，由此为后期的人体跟踪教程和目标抓取教程学习打下坚实基础。注意本篇教程将会调用里程计及其简单应用教程中所编写的定点移动和定角度转动程序，同时还会使用move_base所提供的python调用接口 什么是行为树 行为树 即状态机，其通过调用机器人其他子模块所提供的接口来控制机器人完成一系列复杂的行为(例如: 简单的人体跟踪)或者根据机器人某些传感器信息做出相应的行为(例如: 传感器检测到潜在危险时中断机械臂操作)，于编译器词法分析器中顺序执行状态机不同，机器人开发中所使用的状态机类型更加丰富，开发起来也更具挑战性。下面的内容将使用python smach框架，面向简单的实际应用需求，讲解三种常用机器人行为树类型写法。 串行行为树 串行行为树是最简单的一种行为树写法，其只需要根据当前状态运行的输出结果来决定下一所要达到的状态即可。虽然写法简单，但串行行为树却足以满足许多应用场景需求。本节我们将首先编写一颗简单行为树来控制机器人在一边长为4米的正方形边上进行无线循环行走。随后，为更加贴近实际应用，我们还将使用move_base所提供的接口来实现简易版的巡逻功能。 绕正方形行走 绕正方形行走程序流程图: Created with Raphaël 2.1.4程序开始右转90度前进4米左转90度 demo启动流程于对应效果: 1 输入demo启动指令 roslaunch handsfree_smach demo_smach_serial_square.launch 桌面出现stage画面，图中蓝色小方块为机器人，其正处于stage坐标系中的(-4.0, -4.0)位置，面朝Y轴正方向: 2 观察stage窗口，此时stage中的蓝色小方块正在进行右转动作，在右转结束后，方块开始绕边长为4米的正方形行走。stage输出如下图所示，若要停止该程序，请直接关闭运行改程序的终端即可 简易版巡逻 由于实际应用环境需要机器人带有壁障功能，2-1节中所编写的绕边行走程序是很难在实际场景中有所应用的，为提供壁障功能，我们将移动命令发送端改为move_base，即我们只需向move_base系统提供几个全局目标点，而由move_base系统来进行路径规划和机器人移动控制。其实现步骤可分为两个部分: 获取兴趣目标点、根据目标点列表编写行为树，具体步骤如下所示(在学习本节之前，我们强烈建议您先完成雷达建图教程和自主导航教程): 第一部分-巡逻“兴趣点”选取 1 根据雷达建图教程中所介绍的方法，对巡逻目标区域进行建图。在地图建立完毕后，将其以.bmp格式保存在handsfree_stage/world文件夹中，打开同级目录下的handsfree_stone.world文件(或者新建一个.world后缀结尾的文件，并将handsfree_stone.world文件中内容粘贴到该新建文件中)，并对world文件中参数做相应修改: 2 打开stage模拟平台(若你使用了自己所创建的.world文件请务必修改launch文件中world文件地址,并对size参数进行调试直到stage中的地图于rviz中的地图可以匹配为止)，该过程可参考这篇文章 roslaunch handsfree_stage stage_handsfree_room.launch 桌面出现stage窗口，stage中已经加载了在步骤1中所保存的地图和蓝色机器人一个: 3 运行map_server节点和amcl节点(已经写在了move_base_amcl.launch一个文件中)，同时打开rviz接收相关话题 roslaunch handsfree_stage move_base_amcl_stage.launch 若运行无误，则运行终端和rviz显示结果如下: 4 根据机器人在stage中的实际位置设置amcl算法的初始位置(设置方法可参考自主导航教程中初始位置标定)，在初始位置设置完成后。我们打开新的终端，执行命令: rostopic echo /amcl_pose 执行成功后终端输出amcl粒子滤波算法对机器人当前位置信息的最优估计: 拖动stage中的机器人到\"兴趣点\"，在到达目标点后切换到显示/amcl_pose的终端，记录amcl算法对机器人当前位置定位信息的最优估计。 第二部分-简易巡逻 在前一部分中我们根据实际需求的需要，选取了地图几个点作为巡逻的\"兴趣点\"，在这一部分中我们将采用move_base系统所提供的python接口以及python smach框架将前一部分选取的\"兴趣点\"作为目标点来编写简易巡逻程序。 1 本节的串行行为树写法可参考2-1部分，若对move_base所提供的python接口不太熟悉的读者，可参考这篇教程 2 本节所提供的demo运行指令如下所示(运行前先确保smach_patrol.py已获得可执行权限): roslaunch handsfree_smach demo_smach_patrol.launch 若运行无误，则桌面显示stage画面和rviz界面如下所示: 3 将窗口切换至stage和rviz，发现move_base正在进行路径规划，stage中的机器人正根据第一部分。 并发同步行为树 需要对python smach所提供的Concurrent State Machine接口进行学习的读者，请先参考这篇官方文档。关于\"Concurrent\"这个词，笔者认为更加准确的翻译应该为\"并发\"----即并发地执行多个状态的代码，而pyhon smach则是向用户提供了这种并发执行的接口，同时通过由用户指定\"outcome_map\"来实现多个并发执行状态的同步操作。 关于同步的解释 考虑到存在一些读者没有学习过操作系统相关课程，下面用一个简单例子向大家解释一下“同步”的含义: 假定现有3个事件A、B、C，事件C需要事件A，B中所产生的数据，因此事件C需在事件A，B执行完毕后才能开始执行，事件A ，B则是并发执行，并且无法确定哪个事件会首先结束。此时我们需要一种机制，通过使用这种机制来确保事件A，B均执行完毕且有数据输出时，事件C才开始执行。这种机制即同步，可通过使用系统所提供的互斥锁或者信号量来实现多个线程的同步。 使用并发同步行为树 并发同步行为树可适用于很多实际应用场景，但为便于大家加深对并发同步行为树的理解，本节将使用python smach所提供的Concurrent State Machine接口以及之前所编写的定点移动程序来实现对两个机器人的并发同步控制。 并发控制两台机器人程序流程图: Created with Raphaël 2.1.4已有机器人0号，1号在stage中0号移动3m，1号移动1m0号移动1m，1号移动3m0号移动-3m，1号移动-1m0号移动-1m，1号移动-3m 注意:0号机器人和1号机器人均是以相同速度同时进行移动(即并发运行过程)，若一个机器人完成了目标距离的移动，需停留在原地等待另一台机器人结束运动后才能开始下一次运动(即同步过程) demo启动流程与对应效果: 1 打开终端输入以下指令，启动stage模拟平台和并行状态机程序 roslaunch handsfree_smach demo_smach_concurrence.launch 桌面出现stage画面，stage中出现了两台机器人，均面朝Y轴正方向 观察两个机器人的运动情况：两台机器人先同时运动一会儿，随后其中一台停止运动，待另外一台机器人达到目标点后，两台机器人再次同时开始运动。(可以理解为每次停止就是一次并发) 抢占式行为树 抢占式行为树是三种行为树类型中最为复杂的，但却是最能体现机器人特点的决策方法----即机器人通过传感器对外部环境的感知数据来实时改变机器人当前行为。在进行本节学习之前，您最好已经理解了并发同步行为树的运行机制并且已经熟悉了python smach所提供的大部分官方教程。 抢占式行为树运行机制 相信学习过ros actionlib的读者，对这个“抢占”词并不陌生，即某个任务正在执行时接收到其它程序的抢占请求，随即接收到抢占请求的任务对该请求做出响应，中断当前正在执行的任务(注意不是操作系统强制中断这个程序，而是由程序员编写代码检测并接收抢占响应，随后根据抢占请求来决定是否中断当前正在执行的任务)。python smach所提供的抢占机制亦是如此运行方式，每当一个状态完成或者状态机接收到某个话题所传递的消息时，可根据状态输出结果或者接收到的消息内容来决定是否向并发运行的其它状态发出抢占请求，而其他并发运行的状态接收到抢占请求后做出相应响应。 使用抢占式行为树 抢占式行为树将在后面的人体跟踪教程和目标抓取教程有所涉及，为便于大家加深对抢占式行为树的理解，本节将基于2-1节的绕正方形行走应用“做二次开发”，在机器人处于移动状态时同时加入“激光检测”状态，即实现机器人在移动的同时，使用激光对机器人前方障碍物进行检测，当发现机器人前方一定范围内存在障碍物时，便发送指令使机器人停止运动，当激光检测到前方障碍物被挪走时，再次发送指令使机器人继续绕正方形行走。 抢占行为树实例程序流程图: Created with Raphaël 2.1.4假定有一个robot和一个可移动障碍物block在stage中robot绕正方形行走前方是否有障碍物robot停留在原地前方是否有障碍物yesnoyesno demo启动流程于对应效果: 1 运行激光检测节点(请先确认laser_detection.py已获得可执行权限): rosrun handsfree_smach laser_detection.py 若运行成功，终端不会有任何输出。执行步骤2即可。 2 启动终端输入以下指令，启动stage模拟平台和抢占状态机程序: roslaunch handsfree_stage demo_smach_preemption.launch 桌面出现stage画面，在stage中蓝色方块为机器人，红色方块为可移动障碍物: 若终端无错误输出，将窗口切换到步骤1所打开的stage文件，发现蓝色小方块已经开始绕正方形移动。使用鼠标将红色可移动障碍物拖动到蓝色小方块正前方0.5米到1米距离内，此时机器人将停止移动。再次将红色可移动障碍物挪开，机器人继续绕正方形移动。效果如下所示： 调试行为树 这部分为帮助读者更加合理的理解行为树，以实际应用为背景，编写了四个简单的模拟程序，由于程序本身内容不多，所以并没有使用ROS所提供的smach可视化工具smach_viewer(见下图)。 考虑到实际开发过程中所编写的行为树会更加复杂而且还可能会涉及状态间的数据传输，所以学会使用ROS所提供的smach可视化工具是很有必要的。而且smach_viewer的使用方法并不复杂，您只需在您状态机中添加几行代码，在运行状态机的过程中同时打开smach_viewer即可查看当前状态机运行情况。其详细使用方法可参考官方教程 Copyright © 深圳朝闻道智能信息科技有限公司 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-07-09 10:21:24 "},"docs/Tutorial/Advanced/Object-Recognition/":{"url":"docs/Tutorial/Advanced/Object-Recognition/","title":"目标识别","keywords":"","body":"Copyright © 深圳朝闻道智能信息科技有限公司 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-06-02 16:12:07 "},"docs/Tutorial/Advanced/Person-Follower/":{"url":"docs/Tutorial/Advanced/Person-Follower/","title":"人体跟踪","keywords":"","body":"Copyright © 深圳朝闻道智能信息科技有限公司 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-06-02 16:12:07 "},"docs/Tutorial/Advanced/Object-Pick-Place/":{"url":"docs/Tutorial/Advanced/Object-Pick-Place/","title":"目标抓取","keywords":"","body":"一、前言 HandsFree团队在其最新的Giraffe移动机器人平台上使用了HF中型机械臂，其设计原型来自于西工大舞蹈机器人基地家政组晓萌机器人的老机械臂。作为之前负责过晓萌机械臂软件部分的队员，我把自己曾经开发机械臂时所总结的一些方法和及经验分享出来，当然，写得不对的地方欢迎各位大神指正，也欢迎正在研究机械臂的大神能在此留下自己宝贵的开发经验。 二、技术介绍 机械臂作为机器人最为重要的执行器，赋予了机器人与外部世界环境进行物理交互的能力。这使得机器人的智能不仅仅停留在识别和规划层上，还能通过实际的操作将其真正的表达出来。目前国内外机械臂研究的热点主要集中在机械臂自主精确抓取、放置物体上，而根据本人之前的开发经历，要想让机械臂能完美地执行一系列复杂且精确的操作从而使末端执行器到达预定的位置是很难的，这需要我们理解并掌握很多与机械臂解算相关的数学知识。我相信这会让很多非专业开发者感到头疼，不过借助于第三方开源软件，比如ROS和MoveIT！机械臂的开发就会相对来说简单很多。下面，我分机械、电子和软件三个方面，详细地讲解一下自己在开发过程中所总结的一些技术要点。最后，你可以在开发代码（在ROS Indigo下能成功编译并运行，不支持ROS Kinetic）和问题汇总中找到我之前整理的相关资料。 1、机械 我们机器人的机械臂在机械设计上有一些不一样的地方。相比于其他使用大扭矩舵机或电机作为关节的机械臂，我们使用了由同步轮和同步带所组成的机械结构，这种独特的结构使得我们的机械臂在一定程度上拥有了抓取更重物体的负载能力。除此之外，机械臂末端的手爪也由上一代的对称张开闭合的结构变成了平行夹紧的形式，即两个金属滑块可以通过在滑轨上对称平行的移动。这使得手爪可以适应不同粗细、形状的物体，为抓紧物体提供最基本的保障。当然，这个机械臂也曾经给我造成过一些小困扰，我会在下面的软件部分讲到，通过这个困扰的解决，你就可以理解为什么机械的设计在某种程度上会影响软件代码的编写。 2、电子 电子部分作为连接机械臂软硬件的重要组成部分，主要的任务是负责将软件组通过RS-485传过来的数据进行解析，并且以最快的速度传递给接有驱动盒的电机来实时地控制机械臂。同样的，通过电机编码器返回的数据可以用来记录每个机械臂关节的实时状态，经过一定的数学解算，就可以将其作为运动规划层的输入，为复杂运动的规划提供基本的保证。机械臂控制使用的是位置闭环算法，具体这方面我了解的并不是很多，不过之前用起来还是很稳定的。 3、软件 从软件架构图中可以很清楚的看到，机械臂的软件层主要由三个部分组成，从下到上依次为：硬件接口层、运动规划层和任务决策层。 (1)、硬件接口层 机械臂硬件接口层的设计理念来源于ROS Control。ROS Control是ROS提供的软件与硬件之间进行数据通信的中间件，它对硬件进行了抽象，统一了数据通信的接口，并通过插件的形式封装了一些常用的运动控制算法，为建立机器人软硬件模块之间的数据通路提供了便捷。 ROS Control提供的硬件抽象层主要负责管理机器人的硬件资源，而控制器从抽象层请求资源即可，并不直接接触硬件。这提高了代码的复用率和可移植性。 首先，让我们先看一下ROS Control官方提供的数据流图是什么样子的： 细心的读者可能会发现这两个架构图在硬件接口层部分有一些不一样的地方。接下来我就讲解一下硬件接口层部分各子模块的功能，并解释彼此不同的原因。 实体机械臂： 这一部分指的就是真实客观存在的机械臂。STM32嵌入式控制器使用位置PID闭环算法来计算由硬件抽象层通过串口通信方式发过来的关节数据，并将计算好的数据直接发送给电机对其进行控制。同时，电机的编码器也将电机实时的位置数据经串口通信返回给上面的硬件抽象层。 硬件抽象层： 硬件抽象层和硬件直接打交道，通过write和read方法来完成对硬件的相关操作。硬件抽象层跟上面官方提供（红色的部分）的有一些不太一样的地方在于我并没有使用ROS Control提供的Transmissions（数据转换）和Joint Limits(关节限位）的API。原因的话，我在下面会讲到。这首先简要的介绍一下什么是Transmissions和Joint Limits。 Transmissions： Transmissions就是机器人每个运动关节和电机之间的数学映射。因为机械臂关节结构的不同，会导致机器人上层规划所使用的Joint与Actuator数据之间存在明显的偏差。比如说有简单齿轮和同步带驱动的，有锥齿轮差动机构，四连杆机构等。Transmissions提供的接口中包含有解决上面这些结构进行数据转换的映射公式。 Joint Limits： Joint Limits主要是维护了一个关节限位的数据结构，里面可以包含的数据种类不仅仅是常用的关节位置、速度、力矩、加速度等方面的限位，还可以储存具有安全作用的位置软限位、位置边界和速度边界等。 至于我为什么没有使用以上两个模块的原因，主要是参考了西工大一小学生曾经在Exbot上发表的有关ROS Control的文章。下面就截取其中的一小部分： 以上两个模块是因为URDF中有相应的标签，写了一堆可以直接Load的，但是实际用处并不是很大。它的设计思想是想在URDF中表示更多的信息，这些信息在Gazebo中可以给出更多的细节。但是解析URDF的程序使得RobotHW体量很大，而且这些细节会因为机器人本体通讯暴露给ROS的细节量而不尽相同，而且还会显著提高编程复杂度，所以这些信息显得冗余，而应用这些信息的库也就显得冗余。 之前，我是有尝试过在RobotHW中加载URDF中的相关标签，不过用起来确实就如同小学生所说的那样，比较麻烦，而且还很冗余。因此，我根据机械组队员提供的有关机械臂关节电机转换的数学公式封装了相应的函数，至于Joint Limits，我是在规划层的地方进行了指定。 控制器管理器： 控制器管理器提供一种通用的接口来管理不同的ROS Controllers，它可以加载、开始运行、停止运行、卸载不同的Controller，并且提供了多种工具来完成这些操作。Controller Manager的输入就是ROS上层应用的输出。在这里面，我用到了Joint Command Controller和Joint State Controller，它们分别可以完成对每个关节的控制以及读取硬件接口中关节的状态。 好的。前面讲了很多新的概念，这里我们还是找个案例来具体的分析一下。这里，以我之前整理的源码作为参考，分析一下机械臂分别在Gazebo仿真和物理物理环境中是如何体现上面那些概念的。 首先看一张来自Gazebo官网的ROS Control架构图： 从图中可以看到，Simulation和Hardware之上的Hardware Resource和Controller Manager是一样的，这很清晰地体现了ROS Control的底层无关性，即无论使用的是抽象的仿真还是具体的硬件，只要程序能继承RobotHW硬件抽象层的基类来做到数据接口的统一，Controller Manager就可以对相应的资源进行管理。 对于Simulation和Hardware来说，它们内部架构相似，但配置以及使用方式是不一样的。Simulation的RobotHW部分，Gazebo官方已经将其实现，并且提供了相应的ROS Control插件来从机械臂的URDF文件中载入所需的数据。用户只需写好URDF和YAML文件，并使用ROS Launch将其整合到一起就万事大吉了。 而对于Hardware这部分来说，除了上面说到的配置之外，我们还需要自己编写C++代码来继承RobotHW基类，并在里面分别使用命令和状态硬件接口句柄对相应的关节数据进行注册，然后再将不同的硬件接口注册到RobotHW上。最后，我们还要自己编写函数完成对关节和电机数据的相互转换，并且根据指定的通信协议，实现read和write函数。 仿真部分： xm_arm_description/gazebo/xm_arm_gazebo_transmission.xacro 每个关节都添加了Hardware Interface，并且在具有父子关系的两个关节之间添加了对应的Transmission。 transmission_interface/SimpleTransmission PositionJointInterface PositionJointInterface 1 transmission_interface/SimpleTransmission PositionJointInterface PositionJointInterface 1 transmission_interface/SimpleTransmission PositionJointInterface PositionJointInterface 1 transmission_interface/SimpleTransmission PositionJointInterface PositionJointInterface 1 transmission_interface/SimpleTransmission PositionJointInterface PositionJointInterface 1 transmission_interface/SimpleTransmission PositionJointInterface PositionJointInterface 1 xm_arm_description/gazebo/xm_gazebo_ros_control.xacro 为了让Gazebo可以识别Transmission标签，需要添加Gazebo的ROS Control插件。 /xm_arm gazebo_ros_control/DefaultRobotHWSim xm_arm_gazebo_controller_config/xm_arm_gazebo_joint_position.yaml 使用YAML格式的文件来声明我们所需要使用的Controller，以及对应的参数。 xm_arm: # Position Controllers joint_lift_position_controller: type: position_controllers/JointPositionController joint: joint_lift pid: {p: 100.0, i: 0.01, d: 10.0} joint_waist_position_controller: type: position_controllers/JointPositionController joint: joint_waist pid: {p: 100.0, i: 0.01, d: 10.0} joint_big_arm_position_controller: type: position_controllers/JointPositionController joint: joint_big_arm pid: {p: 100.0, i: 0.01, d: 10.0} joint_forearm_position_controller: type: position_controllers/JointPositionController joint: joint_forearm pid: {p: 100.0, i: 0.01, d: 10.0} joint_wrist_pitching_position_controller: type: position_controllers/JointPositionController joint: joint_wrist_pitching pid: {p: 100.0, i: 0.01, d: 10.0} joint_wrist_rotation_position_controller: type: position_controllers/JointPositionController joint: joint_wrist_rotation pid: {p: 100.0, i: 0.01, d: 10.0} joint_finger_left_position_controller: type: position_controllers/JointPositionController joint: joint_finger_left pid: {p: 100.0, i: 0.01, d: 10.0} joint_finger_right_position_controller: type: position_controllers/JointPositionController joint: joint_finger_right pid: {p: 100.0, i: 0.01, d: 10.0} xm_arm_gazebo_controller_config/xm_arm_gazebo_joint_states.yaml 使用Joint State Controller来发布每个关节的实时状态。 xm_arm: # Publish all joint states joint_state_controller: type: joint_state_controller/JointStateController publish_rate: 50 xm_arm_bringup/launch/xm_arm_bringup_gazebo_joint_control.launch 最后编写Launch文件来启动Controller Manager中的Spawner，加载上述插件。并启动Gazebo和Rviz载入相关的机械臂模型。 在终端中输入以下命令启动Motion Control测试。 $> roslaunch xm_arm_bringup xm_arm_bringup_gazebo_joint_control.launch $> rosrun xm_arm_teleop xm_arm_teleop_position_keyboard 你可以使用键盘上的按键来控制机械臂每个关节的移动位置。 硬件部分： xm_arm_robot_hardware/include/xm_arm_robot_hardware/xm_arm_robot_hardware.h 创建子类继承RobotHW父类，并且声明了一些函数和变量。 class ArmRobotHardware : public hardware_interface::RobotHW { public: ArmRobotHardware(ros::NodeHandle nh); ~ArmRobotHardware(); ros::Time getTime(); ros::Duration getPeriod(); ros::CallbackQueue* getCallbackQueue(); void read(const ros::Time, const ros::Duration period); void write(const ros::Time, const ros::Duration period); bool start(); void stop(); double getFreq() const; private: void publishArmCommand(const u_int8_t func, const u_int8_t jnt_id, const float jnt_pos); void publishArmJState(const u_int8_t func, const u_int8_t jnt_id); void getArmStateCallback( const xm_arm_msgs::xm_ArmSerialDatagram::ConstPtr& msg); void getArmStatusCallback( const xm_arm_msgs::xm_ArmSerialDatagram::ConstPtr& msg); bool checkArmStatus(); void transPositionJointToActuator(); void transPositionActuatorToJoint(); private: ros::NodeHandle nh_; ros::CallbackQueue callback_queue_; ros::Publisher arm_serial_pub_; ros::Subscriber arm_state_sub_; ros::Subscriber arm_status_sub_; int arm_command_id_; int arm_state_id_; double freq_; hardware_interface::JointStateInterface jnt_state_interfece_; hardware_interface::PositionJointInterface jnt_position_interface_; hardware_interface::VelocityJointInterface jnt_velocity_interface_; std::vector jnt_name_; std::vector act_name_; std::map jnt_pos_; std::map jnt_vel_; std::map jnt_eff_; std::map act_pos_; std::map jnt_cmd_; std::map act_cmd_; std::vector jnt_stamp_; enum HARDWARE_STATUS {UNKNOWN, READY, RUNNING, ERROR}; std::vector jnt_status_; }; xm_arm_robot_hardware/src/xm_arm_robot_hardware.cpp 初始化关节和电机数据，并使用Hardware Interface对相应的数据进行注册，最后初始化与串口通信有关的Topic。 ArmRobotHardware::ArmRobotHardware(ros::NodeHandle nh) : nh_(nh), freq_(20) { nh_.setCallbackQueue(&callback_queue_); jnt_name_.push_back(\"joint_lift\"); jnt_name_.push_back(\"joint_waist\"); jnt_name_.push_back(\"joint_big_arm\"); jnt_name_.push_back(\"joint_forearm\"); jnt_name_.push_back(\"joint_wrist_pitching\"); jnt_name_.push_back(\"joint_wrist_rotation\"); act_name_.push_back(\"actuator_lift\"); act_name_.push_back(\"actuator_waist\"); act_name_.push_back(\"actuator_big_arm\"); act_name_.push_back(\"actuator_forearm\"); act_name_.push_back(\"actuator_wrist_left\"); act_name_.push_back(\"actuator_wrist_right\"); for (int i = 0; i ( \"xm_arm_serial/send_arm_command\", 1000); arm_state_sub_ = nh_.subscribe(\"xm_arm_serial/receive_arm_state\", 1000, &ArmRobotHardware::getArmStateCallback, this); arm_status_sub_ = nh_.subscribe(\"xm_arm_serial/receive_arm_status\", 1000, &ArmRobotHardware::getArmStatusCallback, this); } 根据机械臂公式，实现关节和电机数据之间的互相转换。 void ArmRobotHardware::transPositionJointToActuator() { act_cmd_[\"actuator_lift\"] = -jnt_cmd_[\"joint_lift\"] * 100; act_cmd_[\"actuator_waist\"] = jnt_cmd_[\"joint_waist\"]; act_cmd_[\"actuator_big_arm\"] = -jnt_cmd_[\"joint_big_arm\"] * 1.6667; act_cmd_[\"actuator_forearm\"] = -jnt_cmd_[\"joint_forearm\"] + jnt_cmd_[\"joint_big_arm\"] * 1.6667; act_cmd_[\"actuator_wrist_left\"] = -(-jnt_cmd_[\"joint_big_arm\"] * 1.6667 + jnt_cmd_[\"joint_forearm\"] * 1.6000 + jnt_cmd_[\"joint_wrist_pitching\"]) * 0.6250 + jnt_cmd_[\"joint_wrist_rotation\"] * 0.7917; act_cmd_[\"actuator_wrist_right\"] = -(-jnt_cmd_[\"joint_big_arm\"] * 1.6667 + jnt_cmd_[\"joint_forearm\"] * 1.6000 + jnt_cmd_[\"joint_wrist_pitching\"]) * 0.6250 - jnt_cmd_[\"joint_wrist_rotation\"] * 0.7917; } // Because autuator's direction is not unified, the signs of positive and // negative may have problem in the following formula. void ArmRobotHardware::transPositionActuatorToJoint() { jnt_pos_[\"joint_lift\"] = -act_pos_[\"actuator_lift\"] * 0.010; jnt_pos_[\"joint_waist\"] = act_pos_[\"actuator_waist\"]; jnt_pos_[\"joint_big_arm\"] = -act_pos_[\"actuator_big_arm\"] * 0.600; jnt_pos_[\"joint_forearm\"] = -(act_pos_[\"actuator_forearm\"] + act_pos_[\"actuator_big_arm\"]); jnt_pos_[\"joint_wrist_pitching\"] = -(-act_pos_[\"actuator_big_arm\"] * 0.6400 - act_pos_[\"actuator_forearm\"] * 1.6000 + (act_pos_[\"actuator_wrist_left\"] + act_pos_[\"actuator_wrist_right\"]) * 0.8000); jnt_pos_[\"joint_wrist_rotation\"] = (act_pos_[\"actuator_wrist_left\"] - act_pos_[\"actuator_wrist_right\"]) * 0.6316; } 实现定制的read和write函数。 void ArmRobotHardware::read(const ros::Time, const ros::Duration period) { for (size_t i = 0; i 0.5) { ROS_WARN_STREAM(\"Reading timeout!\"); return ; } } } void ArmRobotHardware::write(const ros::Time, const ros::Duration period) { transPositionJointToActuator(); for (size_t i = 0; i 0.5) { ROS_WARN_STREAM(\"Writing timeout!\"); return ; } } } xm_arm_hardware_controller_config/config/xm_arm_hardware_joint_trajectory.yaml Joint Trajectory Controller可以提供经过时间差值的连续关节轨迹，是MoveIT!中默认的数据接口。 xm_arm: arm_controller: type: \"position_controllers/JointTrajectoryController\" joints: - joint_lift - joint_waist - joint_big_arm - joint_forearm - joint_wrist_pitching - joint_wrist_rotation xm_arm_hardware_controller_config/config/xm_arm_hardware_joint_states.yaml 这个与上面所仿真使用的Controller是一样的。 xm_arm: joint_state_controller: type: joint_state_controller/JointStateController publish_rate: 50 xm_arm_hardware_controller_config/config/xm_arm_hardware_joint_names.yaml 加载关节名字到ROS的参数服务器中。 xm_arm: joint_names: - joint_lift - joint_waist - joint_big_arm - joint_forearm - joint_wrist_pitching - joint_wrist_rotation 以上就是硬件接口层的全部内容了。作为整个机械臂软件架构最底层的部分，它的重要性不言而喻。根据我之前开发机械臂的经验，只有编写出稳定且鲁棒的的硬件接口层，才能为之上的运动规划提供强有力的保证。否则，等到机械臂出现暴走失控的情况的时候就麻烦了（我之前就曾入过这样的坑！）。 (2)、运动规划层 运动规划层在机械臂的自主抓取中扮演了非常重要的角色。而对于运动规划本身来说，里面涉及了非常多的专业知识，比如运动学正逆解算、碰撞检测算法、3D环境感知、动作规划算法等，以上任何一个方面都需要我们长时间的积累才能理解清楚，而对于那些想立马上手机械臂的初学者来说，这简直就是一个灾难。 而幸运的是，ROS提供了强大且易用的MoveIt!包，它可以让你在较短的时间内实现仿真乃至实体机械臂的运动学规划演示。 首先，简要地介绍一下什么是MoveIt!。以下是MoveIt官网给出的定义： MoveIt! is state of the art software for mobile manipulation, incorporating the latest advances in motion planning, manipulation, 3D perception, kinematics, control and navigation. It provides an easy-to-use platform for developing advanced robotics applications, evaluating new robot designs and building integrated robotics products for industrial, commercial, R&D and other domains. 概括来说，MoveIt!是ROS中与移动操作相关的组件包的集合。它包含了运动规划、操作控制、3D感知，运动学，碰撞检测等。当然，最重要的是MoveIt!提供了非常友好的配置和调试界面。 下图是MoveIt的总体框架： 这张图我在学习MoveIt!的时候看过很多遍，理解这个架构图对于学习MoveIt!非常重要。从图中可以看到，move_group是MoveIt!最核心的部分。它将其他独立的组件集成到一起，为使用者提供了一系列可以使用的命令和服务。 用户接口： 用户可以使用C++、Python或者GUI来访问move_group。一般对于初学者来说，GUI和Python的使用会更多一些。 配置： move_group本质上还是一个ROS的节点，它需要使用ROS的参数服务器来获取以下三种信息。 URDF： move_group需要机械臂的URDF文件来进行运动规划。 SRDF： move_group在启动时会寻找机械臂的SRDF文件，它可以通过使用MoveIt! Setup Assistant自动生成。 MoveIt!配置： move_group在启动时会加载机械臂的关节限位、动力学、运动规划、感知以及其他相关信息。所有以上的配置信息都可以通过使用MoveIt! Setup Assistant自动生成。 机器人接口： move_group使用ROS中的Topic和Action两种机制来与机械臂进行数据通信。它可以获取当前机械臂的位置信息，点云数据以及其他传感器数据，并且发送命令给机械臂的Controller。 关节状态信息： move_group会监听机械臂的/joint_states主题来获取当前的状态信息。注意：move_group只管监听，你需要自己给机械臂配置好Joint State Controller。 坐标转换信息： move_group可以订阅机械臂的TF主题来确定机械臂内部各关节之间的位置变换关系。跟上面一样，你需要自己运行Robot State Publier节点来发布坐标转换。 控制器接口： move_group使用Follow Joint Trajectory类型的Action接口来与Controller进行数据通信。move_group自己是不带Action接口的，它是使用了一个特殊的插件来发布上述Follow Joint Trajectory类型的Action，而对于机械臂来说，你依然需要自己配置上述类型的Controller来订阅机械臂的数据。 规划场景： Planning Scene指的是机械臂本身以及其周围环境的表示。 扩展能力： move_group的所有组件都是以独立插件的形式实现的，而且这些插件可以通过使用ROS的参数文件或插件库来进行配置，这使得move_group拥有了强大的定制以及可扩展能力。 接下来，我们介绍一下Motion Planning。 这里我引用古月居前辈对运动规划的解释： 假设我们已知机器人的初始姿态和目标姿态，以及机器人和环境的模型参数，那么我们就可以通过一定的算法，在躲避环境障碍物和放置自身碰撞的同时，找到一条到达目标姿态的较优路径，这种算法就称为机器人的运动规划。机器人和环境的模型静态参数由URDF文件提供，在默写场景下还需要加入3D摄像头、激光雷达来动态检测环境变化，避免与动态障碍物发生碰撞。 在MoveIt!中，运动规划算法是由运动规划器算出来的。当然，运动规划算法有很多，每一个运动规划器都是MoveIt的一个插件，可以根据需求选用不同的规划算法。MoveIt!默认使用的是OMPL。OMPL(Open Motion Planning Library)是开源运动规划库的简写，它提供基于随机化的运动规划器。 运动规划请求： 在让运动规划器进行运动规划之前，我们要先发送一个运动规划的请求。这个请求可以是新的机械臂或末端执行器的位置。为了让运动规划器规划出来的轨迹符合要求，我们需要指定一些约束条件： 位置约束： 约束机械臂Link的位置。 方向约束： 约束机械臂Link的方向。 可见性约束： 约束Link上的某点在某些区域的可见性。 关节约束： 约束Joint的运动范围。 自定义约束： 使用自定义的回调函数来指定约束条件。 运动规划结果： move_group节点最终将会根据上面的运动规划请求，生成一条运动轨迹。这条轨迹可以使机械臂移动到预想的目标位置。请注意：move_group输出的是一条轨迹，而不是路径。对于机械臂来说，路径是使末端执行器移动到目标位置的过程中，中间所经历的一系列独立的位置点。而轨迹则是在路径的基础上，通过加入速度、加速度约束以及时间参数来使机械臂运动的更加平滑。 规划请求适配器： 在运动规划器的输入输出端分别有两个规划请求适配器。它们的作用分别是对规划请求和规划结果进行预处理和后期处理。MoveIt!提供了几种默认的适配器来完成一些特定的功能。 FixStartStateBounds: 当机械臂的一个或多个关节的初始状态稍微超出了URDF文件中所定义的Joint Limits后，为了能让运动规划器可以运行，FixStartStateBounds适配器会通过将关节状态移动到Joint Limits处来解决这个问题。不过，如果机械臂关节的偏差很大的话，这种靠软件方式修正的方式就不适用了。 FixWorkspaceBounds: 这个适配器会默认地生成一个10x10x10立方米的机械臂规划空间。 FixStartStateCollision: 如果已有的关节配置文件会导致碰撞，这个适配器可以采样新的配置文件，并根据摇摆因子来修改已有的配置文件，从而保证新的机械臂不会发生碰撞。 FixStartStatePathConstraints: 如果机械臂的初始姿态不满足路径约束，这个适配器可以找到附近满足约束的姿态作为机械臂的初始姿态。 AddTimeParameterization: 这个适配器非常重要。它把从运动规划器中输出的空间路径按等距离进行划分，并在其中添加加速度、加速度约束，以及时间戳等必要信息。 Planning Scene Planning Scene用来表示机械臂周围的外部世界并且保存机械臂自己本身的状态。它通过监听对应的Topic来获取关节状态信息、传感器信息。并可以根据传感器信息和用户的输入，生成机器人周围3D世界空间的表示。 3D Perception 简单来说，3D Perception使用插件来获取点云和深度图像数据，并据此生成OctoMap，为之后机械臂的碰撞检测提供基础。 Kinematics 运动学算法是机械臂各种算法中的核心，尤其是反向运动学算法IK(Inverse Kinematics)。MoveIt!使用插件的形式可以让用户灵活的选择需要使用的反向运动学算法，也可以选择自己的算法。 Collision Checking MoveIt!使用CollisionWorld对象进行碰撞检测，采用FCL(Flexible Collision Library)功能包。碰撞检测是运动规划中最耗时的运算，往往会占用90%左右的时间，为了减少计算量，可以通过设置ACM(Allowed Collision Matrix)来进行优化。 好的，讲了这么多抽象的概念，就让我们像上一节讲ROS Control一样，用具体的例子来实践一下。 首先，你需要机械臂的URDF文件，而且保证里面所包含的Link(连杆)、Joint(关节)、运动学参数、动力学参数、可视化和碰撞模型没有问题。这里要注意一下，通过SolidWorks插件导出的URDF文件，它默认使用的碰撞检测模型和可视化模型是一样的。为了提高运动规划的执行速度，你可以使用MeshLab来简化模型（.stl或.dae零件）的点和面。 xm_arm_description/urdf/xmbot_with_arm.urdf.xacro 之后，运行下面命令来启动MoveIt! Setup Assistant。 rosrun moveit_setup_assistant moveit_setup_assistant 之后你可以根据MoveIt! Setaup Assistant官网教程完成机械臂的配置。虽然这里我没有详细讲解配置的每一步（其实是我忘了截图），但这一步是非常重要的。我之前就配置过很多次，但总有问题。所以说配置机械臂MoveIt!参数是需要一定经验的。这里，我主要讲两个我在配置过程中遇到的问题，希望对你有所帮助。 交互式Marker没有在末端执行器上生成： 这个问题曾经困扰了我很久，后来我在Google上搜索了一段时间，终于找到问题的原因和解决办法。出现这个问题的原因是我在配置末端执行器的时候，parent_link没有选择arm组中的link，而是选了gripper组中的。因此，解决办法就是选择arm组中的最顶端的link填入到parent_link中就没问题了。 MoveIt!根据点云数据生成的OctoMap在Rviz中的位置、方向与实际不符： 这个问题的原因，你可以通过可视化Rviz中的TF插件来看到。每个Link都有自己的XYZ方向，如果你机器人的Camera Link的XYZ方向恰好与Rviz所使用的XYZ方向不符，就会出现上述问题。我的解决办法是在URDF中再添加一个或两个虚拟的Link来修正方向上的偏差。 打开用MoveIt! Setup Assistant生成的包，我们可以发现里面有config和launch两个文件夹。这里简要介绍下每个文件的功能。 xm_arm_moveit_config/config/controllers.yaml 这个文件指定了MoveIt!向Controller发布数据的接口。注意：这个配置文件不是用MoveIt! Setup Assistant自动生成的，你需要自己添加。而且name要与Controller配置文件的namespace保持一致。否则，MoveIt!输出的轨迹是没法传送给物理机械臂的。 controller_list: - name: xm_arm/arm_controller action_ns: follow_joint_trajectory type: FollowJointTrajectory default: true joints: - joint_lift - joint_waist - joint_big_arm - joint_forearm - joint_wrist_pitching - joint_wrist_rotation xm_arm_moveit_config/config/fake_controllers.yaml 这是虚拟控制器配置文件，方便我们在没有实体机械臂，甚至没有任何模拟器开启的情况下也能运行MoveIt!。 controller_list: - name: fake_xm_arm_controller joints: - joint_lift - joint_waist - joint_big_arm - joint_forearm - joint_wrist_pitching - joint_wrist_rotation - name: fake_xm_gripper_controller joints: - joint_finger_left - joint_finger_right xm_arm_moveit_config/config/joint_limits.yaml 这里记录了机械臂各关节的位置、速度、加速度的极限。 # joint_limits.yaml allows the dynamics properties specified in the URDF to be overwritten or augmented as needed # Specific joint properties can be changed with the keys [max_position, min_position, max_velocity, max_acceleration] # Joint limits can be turned off with [has_velocity_limits, has_acceleration_limits] joint_limits: joint_big_arm: has_velocity_limits: true max_velocity: 1 has_acceleration_limits: false max_acceleration: 0 joint_finger_left: has_velocity_limits: true max_velocity: 1 has_acceleration_limits: false max_acceleration: 0 joint_finger_right: has_velocity_limits: true max_velocity: 1 has_acceleration_limits: false max_acceleration: 0 joint_forearm: has_velocity_limits: true max_velocity: 1 has_acceleration_limits: false max_acceleration: 0 joint_lift: has_velocity_limits: true max_velocity: 1 has_acceleration_limits: false max_acceleration: 0 joint_waist: has_velocity_limits: true max_velocity: 1 has_acceleration_limits: false max_acceleration: 0 joint_wrist_pitching: has_velocity_limits: true max_velocity: 1 has_acceleration_limits: false max_acceleration: 0 joint_wrist_rotation: has_velocity_limits: true max_velocity: 1 has_acceleration_limits: false max_acceleration: 0 xm_arm_moveit_config/config/kinematics.yaml 记录运动规划的配置参数。 xm_arm: kinematics_solver: kdl_kinematics_plugin/KDLKinematicsPlugin kinematics_solver_search_resolution: 0.005 kinematics_solver_timeout: 0.05 kinematics_solver_attempts: 3 xm_arm_moveit_config/config/ompl_planning.yaml 记录了OMPL算法的各种配置参数。 planner_configs: SBLkConfigDefault: type: geometric::SBL range: 0.0 # Max motion added to tree. ==> maxDistance_ default: 0.0, if 0.0, set on setup() ESTkConfigDefault: type: geometric::EST range: 0.0 # Max motion added to tree. ==> maxDistance_ default: 0.0, if 0.0 setup() goal_bias: 0.05 # When close to goal select goal, with this probability. default: 0.05 LBKPIECEkConfigDefault: type: geometric::LBKPIECE range: 0.0 # Max motion added to tree. ==> maxDistance_ default: 0.0, if 0.0, set on setup() border_fraction: 0.9 # Fraction of time focused on boarder default: 0.9 min_valid_path_fraction: 0.5 # Accept partially valid moves above fraction. default: 0.5 BKPIECEkConfigDefault: type: geometric::BKPIECE range: 0.0 # Max motion added to tree. ==> maxDistance_ default: 0.0, if 0.0, set on setup() border_fraction: 0.9 # Fraction of time focused on boarder default: 0.9 failed_expansion_score_factor: 0.5 # When extending motion fails, scale score by factor. default: 0.5 min_valid_path_fraction: 0.5 # Accept partially valid moves above fraction. default: 0.5 KPIECEkConfigDefault: type: geometric::KPIECE range: 0.0 # Max motion added to tree. ==> maxDistance_ default: 0.0, if 0.0, set on setup() goal_bias: 0.05 # When close to goal select goal, with this probability. default: 0.05 border_fraction: 0.9 # Fraction of time focused on boarder default: 0.9 (0.0,1.] failed_expansion_score_factor: 0.5 # When extending motion fails, scale score by factor. default: 0.5 min_valid_path_fraction: 0.5 # Accept partially valid moves above fraction. default: 0.5 RRTkConfigDefault: type: geometric::RRT range: 0.0 # Max motion added to tree. ==> maxDistance_ default: 0.0, if 0.0, set on setup() goal_bias: 0.05 # When close to goal select goal, with this probability? default: 0.05 RRTConnectkConfigDefault: type: geometric::RRTConnect range: 0.0 # Max motion added to tree. ==> maxDistance_ default: 0.0, if 0.0, set on setup() RRTstarkConfigDefault: type: geometric::RRTstar range: 0.0 # Max motion added to tree. ==> maxDistance_ default: 0.0, if 0.0, set on setup() goal_bias: 0.05 # When close to goal select goal, with this probability? default: 0.05 delay_collision_checking: 1 # Stop collision checking as soon as C-free parent found. default 1 TRRTkConfigDefault: type: geometric::TRRT range: 0.0 # Max motion added to tree. ==> maxDistance_ default: 0.0, if 0.0, set on setup() goal_bias: 0.05 # When close to goal select goal, with this probability? default: 0.05 max_states_failed: 10 # when to start increasing temp. default: 10 temp_change_factor: 2.0 # how much to increase or decrease temp. default: 2.0 min_temperature: 10e-10 # lower limit of temp change. default: 10e-10 init_temperature: 10e-6 # initial temperature. default: 10e-6 frountier_threshold: 0.0 # dist new state to nearest neighbor to disqualify as frontier. default: 0.0 set in setup() frountierNodeRatio: 0.1 # 1/10, or 1 nonfrontier for every 10 frontier. default: 0.1 k_constant: 0.0 # value used to normalize expresssion. default: 0.0 set in setup() PRMkConfigDefault: type: geometric::PRM max_nearest_neighbors: 10 # use k nearest neighbors. default: 10 PRMstarkConfigDefault: type: geometric::PRMstar xm_arm: planner_configs: - SBLkConfigDefault - ESTkConfigDefault - LBKPIECEkConfigDefault - BKPIECEkConfigDefault - KPIECEkConfigDefault - RRTkConfigDefault - RRTConnectkConfigDefault - RRTstarkConfigDefault - TRRTkConfigDefault - PRMkConfigDefault - PRMstarkConfigDefault projection_evaluator: joints(joint_lift,joint_waist) longest_valid_segment_fraction: 0.05 xm_gripper: planner_configs: - SBLkConfigDefault - ESTkConfigDefault - LBKPIECEkConfigDefault - BKPIECEkConfigDefault - KPIECEkConfigDefault - RRTkConfigDefault - RRTConnectkConfigDefault - RRTstarkConfigDefault - TRRTkConfigDefault - PRMkConfigDefault - PRMstarkConfigDefault projection_evaluator: joints(joint_finger_left,joint_finger_right) longest_valid_segment_fraction: 0.05 xm_arm_moveit_config/config/sensors_rgbd.yaml 这个文件用来配置MoveIt!的传感器插件，它可以使MoveIt!订阅点云数据来生成机械臂避障用的OctoMap。注意：这个配置文件不是用MoveIt! Setup Assistant自动生成的，你需要自己添加。 sensors: - sensor_plugin: occupancy_map_monitor/PointCloudOctomapUpdater point_cloud_topic: /head_kinect/depth/points max_range: 10 padding_offset: 0.01 padding_scale: 1.0 point_subsample: 1 filtered_cloud_topic: output_cloud xm_arm_moveit_config/config/xmbot.srdf 这是MoveIt!的主配置文件。这里面记录了我们使用MoveIt! Setup Assistant配置时的参数，里面包含了组群、位姿、末端执行器、虚拟关节，以及碰撞免测矩阵的定义。 下面，我们打开launch文件夹，你会发现里面有很多launch和xml文件。这时候不要慌，因为MoveIt!的模块化设计思想，它将不同的功能进行拆分并放到不同的文件中，所以文件看起来很多，但每一个都不是很长。这里，我只介绍其中几个重要的文件。 xm_arm_moveit_config/launch/demo.launch 这个launch文件是运行MoveIt!的根节点，它里面还包含了其他的launch文件。包括最为重要的move_group.launch。 [/move_group/fake_controller_joint_states] xm_arm_moveit_config/launch/move_group.launch 这个launch文件里面设置了很多运动规划时的参数。 xm_arm_moveit_config/launch/planning_context.launch 这里面使用了机械臂的URDF和SRDF文件，以及运动学解算库。不建议修改。 xm_arm_moveit_config/launch/xmbot_moveit_controller_manager.launch.xml 这个文件用来指定Controller配置文件的位置。注意：这个文件是MoveIt! Setup Assistant自动生成的，但我记得里面什么也没写。你需要下面例子中的那样进行配置。 xm_arm_moveit_config/launch/xmbot_moveit_sensor_manager.launch.xml 这个文件用来指定Sensor配置文件的位置。同上，你也需要自己编辑这个文件。 接下来，让我们运行两个例子来测试一下MoveIt!。 首先，我们测试一下MoveIt!的Motion Planning。请在终端中输入下列命令： $> roslaunch xm_arm_bringup xm_arm_bringup_moveit_and_gazebo.launch 在Rviz中，你可以使用末端执行器上的交互式Marker来移动机械臂到目标位置。接着，你可以在Planning Library的下拉式菜单中选择OMPL库中的某个特定规划算法。然后，点击Plan按钮，Rviz窗口中就会出现一条从初始位置到目标位置的运动轨迹并循环不断地播放。最后，点击Execute按钮，MoveIt!会将上一步规划出来的机械臂关节轨迹通过FollowJointTrajectoryAction接口发送给Gazebo中对应类型的Controller，使得Gazebo中的机械臂可以移动到目标位置，以下是测试的截图。注意：不同的规划算法所用的时间是不一样的。请尝试每一种算法，并记住最优算法的名字，这是为了之后方便在代码中对其进行调用做准备。 第二个例子，我们来测试一下带有Avoid Collision的Motion Planning。同样的，请在终端中输入下列命令： $> roslaunch xm_arm_bringup xm_arm_bringup_moveit_and_gazebo.launch 因为我在Gazebo中给机器人的头部添加了深度传感器的插件，所以当你把桌子放到机器人前方的时候，MoveIt!可以立马从点云Topic中获取物体的信息，并在Rviz中生成可视化的OctoMap。在下一次做运动规划的时候，MoveIt!会将由正方体组成的OctoMap看成障碍物并考虑在内。图中，机械臂的初始位置为伸直形态，我将其从桌子的下方移动到了桌子的正上方，规划的效果如下图所示。 当然，在使用MoveIt!对机械臂进行运动规划的时候并不是每一次都能成功，有些时候会出现超时报错的情况。遇到这种问题的时候，你可以尝试尝试其他OMPL算法，因为不同的OMPL算法可能对不同的情况有各自的优化。 最后，由于时间的缘故，我没能将MoveIt!的C++和Python的使用代码给整理出来，这对于我来说非常遗憾。不过，我相信随着MoveIt!学习教程的越来越丰富，有关如何用代码来做MoveIt!的运动规划会更加容易。 (3)、任务决策层 任务决策层处于整个架构图最顶端，是控制整个机械臂的大脑所在。首先，我要阐明的一点是：这一部分在我那一届机械臂软件代码中并没有实现，这是我后来总结机械臂开发经验的时候重新设计的。 至于我为什么要选择重新设计新的任务决策层，原因其实很明显，就是我们之前的那个存在着很多的不足的地方。我们之前的那个任务决策层架构比较松散，特别是机械臂的Action接口，我们定义了好几种，但是其中有几种的功能比较相近，显得比较冗余。而且状态机可以直接发送Action的Goal到机械臂模块中，换句话说就是没有经过封装的数据是一直暴露在整个任务决策的各个时间段，这会影响数据通信的稳定性，而且这样的代码也是不容易维护和重构的。 当然，除了上面存在的历史问题，还有一个影响我做出改进的因素就是：中科大蓝鹰队可佳服务机器人早期的抓取视频。视频中，可佳机器人的机械臂可以非常精准地操作微波炉，并抓取桌子上三种不同的容器。其中最难的是那个盛有牛奶的碗，整个碗只有一个地方向外伸出了一个手柄，能让机械臂末端手爪精准地抓住碗并且在移动其的过程中不让碗中的牛奶洒出来，这是非常厉害的。当时看完视频之后，我就被深深地震撼了，原来机械臂的自主抓取可以做到这样的程度！后来，西工大一小学生跟我们讲： 这个视频里最厉害的还不是机械臂的抓取，而是可佳机器人的任务决策部分。可佳可以通过对人语义的理解来自动生成相应的任务序列，而且这个任务序列是能被实时的修改和更新的。 因此，我决定对之前的机械臂任务决策模块进行封装，把所有与机械臂相关的软件细节都隐藏起来，最后暴露给外面的只有数据和任务接口。这样可以大大降低模块与模块之间的耦合性，并减少了不必要的进程通信开销，提高了程序运行时的效率。下面，我简要地讲解一下这个部分的原理。 任务决策层的核心简单来说是在其内部定义了一个小型的状态机，它可以根据不同的任务类型、物体位置以及物体的类型来选择不同的数据发给下面的运动规划层。这里我举一个具体的例子来说明其工作的整个流程：首先，机器人决策模块给机械臂的任务决策层发送了一个抓取的状态，任务决策层接收到之后就会在自己事先存储好的状态表中进行查找，如果匹配抓取状态成功，就把表中的状态链取出并放到状态队列中去。每次状态控制器会根据当前状态队列中的子动作来分析其所需要的数据。比如说，抓取状态可以拆分成很多子动作：初始、准备、抓取、手爪张开、手爪夹紧、手握物体等。此时，如果队列中第一个动作是初始，那控制器便会从预先设定好的机械臂位置池中取出相应的位置，并从MoveIt!参数表中取出其所需要的数据，最后通过MoveIt!接口把初始动作发送给运动规划层进行规范和执行。当机械臂完成这个动作后，任务决策层会比较机械臂实际运动的位置和预想位置之间的差值，如果误差小于某个值，其便会返回执行成果给控制器，控制器则会继续地执行下一个状态，直到整个状态队列中的动作都被执行完。如果误差过大，则报错退出，以防止机械臂出现任何不可控的意外情况。 最后，鉴于这一部分只停留在我的设想阶段，目前只供参考。至于最终能不能实现出来，还有待日后的验证。 三、学习流程 1、基础 （1）、开发规范 首先，我承认我对规范有一种近似疯狂的恪守。很多人都觉得学习开发规范对项目开发没有意义，简直就是在浪费时间。可是我一直坚信着：只有好的开发规范，才能产生成功的项目。我把学习开发规范作为基础中的基础，是因为我曾经在项目开发的过程中吃过这样的亏。因此，我希望每个开发者都能在为项目开始贡献之前耐下心来好好学习本团队的开发规范，并严格地执行规范中的内容。这里，我推荐Google开发规范和ROS开发规范。当然，如果你感兴趣的话，你可以看一下我曾经自己整理编写的晓萌团队开发规范。 （2）、版本管理 我认为掌握版本管理可以说是软件开发的必备技能之一，也是提高代码开发效率的绝对利器，希望大家好好地学习一下。版本管理主要涉及Git和GitHub的使用，这方面的学习资料很多，上网搜一下，花一段时间就能入门。 （3）、文档写作 这方面也有很多的开发者不是很重视。但个人认为如果你想成为真正的强者，只会编代码是远远不够的，你还需要优秀的文档写作能力。比如说你在开发的过程中遇到了一些问题，并成功地解决了。这个时候，你应该及时地将遇到的问题和解决办法以项目日志的形式记录下来，这样伴随着项目开发进度的不断向前，日志的内容也会越来越多。我敢保证，若干年之后，你一定会拥有别人绝对没有的宝贵财富！当然，除了开发日志外，你也要学会如何使用Markdown来编写项目文档。Markdown是你与开源世界交流的最重要的工具，一定要学会，况且它也并不是很难学。 （4）、编程能力 这个我就不用讲太多了，我相信如何学习编程，大家可能知道的比我还多。我这里主要想强调一下，一定要重点理解、学习C++。毕竟编译型语言要比解释性语言Python在执行效率上要高，而且对于机械臂开发来说，MoveIt!中的C++ API也要比Python的要多。 （5）、ROS基础 关于如何学习ROS，我推荐跟我曾经同在西工大舞蹈机器人基地的盛盛在易科上发表过的一篇文章：如何学习ROS——盛盛经验谈。这里，我想补充一下，对于机械臂开发来说，除了盛盛在文章里讲到的那些内容之外，各位还要重点理解以下几个部分： Action ROS Control Joint State Publisher Robot State Publisher Joint Trajectory Controller URDF Xacro Launch XML Gazebo Connect to ROS 2、进阶 等你学习完以上的内容之后，我相信你已经打下了坚实的基础。这个时候，你可以开始入门MoveIt!了。学习MoveIt!的时候，一定要多实践，遇到问题多在ROS Answers上搜一搜，我相信大部分问题的解决办法你都能找到。有关机械臂的URDF模型，我推荐刚开始入门的时候先从简单的机械臂模型入手，不要一上来就整个PR2的，一是机械臂关节比较多，二是我估计你的电脑不一定能带的动。 还有就是要熟练地掌握Gazebo仿真软件，因为我觉得并不是每个人都有机械臂，机械臂的成本确实比较高，这个时候如果你学会了如何在仿真环境下搭建机械臂模型并将其与MoveIt!连接在一起，你就能在一定程度上节约时间、资金成本。当然，仿真是永远无法替代实物的，这个我之前在开发机械臂的时候就深刻地体会过，不过，把Gazebo当做算法的前期验证平台还是非常好的。 多看看别人的MoveIt!配置是什么样的，然后你自己再重新地配置几遍，主要是熟悉其中的一些概念。最后，在Rviz里试着拖动机械臂到新的位置，点击Plan按钮看看MoveIt!是怎么通过IK来输出一条平滑的轨迹的。当然，如果你配置好了深度传感器接口的话，可以试一试MoveIt!是如何在有障碍物的情况下进行运动规划的。 总之，想要开发好机械臂，MoveIt!+Gazebo是必不可少的。 3、高级 至此，如果你能按照我说的完成前两步的话，你应该已经会用MoveIt!，并能用其做简单的运动规划了。当然，如果你想成为机械臂开发大神的话，你还需要重点学习MoveIt!的代码API。MoveIt!的API不少，你需要多尝试，找到最适合你们机械臂使用的API（推荐C++的API）。 在MoveIt!中，碰撞检测使用的是FCL库。你需要了解和学习FCL的API，并将其融入到机械臂的运动规划中去。 MoveIt!默认使用OMPL库来做运动规划，你可以去OMPL的官网仔细地学习一下它的使用方法。如果你有时间的话，也可以研究一下其他几种规划器的效果如何，比如STOMP、SBPL、CHOMP等。 如果你认为你已经对MoveIt!的使用了如指掌，你可以尝试挑战一下难度——根据你们自己机械的实际情况，手写IK解算插件并将其集成到OMPL中去。 完成以上之后，你如果发现自己还想在机械臂领域有更多的提升空间，那工程开发显然已经不能满足你的需求了，你需要阅读机械臂方面的论文以及专业书籍。这里我推荐《Robotics - Modelling, Planning and Control》这本书，里面深入地讲解了机器人的建模、轨迹规划以及运动控制等相关内容。 4、资源 以下是我认为学习机械臂比较好的资源，推荐给大家。 (1)、网站 MoveIt!官方文档 (2)、书籍 《Effective_Robotics_Programming_with_ROS_Third_Edition》 《Learning_ROS_for_Robotics_Programming_Second_Edition》 《Mastering_ROS_for_Robotics_Programming》 《Programming_Robots_with_ROS》 《Robot_Operating_System(ROS)_The_Complete_Reference》 《ROS_By_Example_2_Indigo》 《ROS_Robotics_By_Example》 (3)、博客 西工大一小学生： ros_control攻略 古月居： ROS探索总结（二十五）——MoveIt!基础 ROS探索总结（二十六）——MoveIt!编程 ROS探索总结（三十一）——ros_control redefine： 运动规划 (Motion Planning): MoveIt! 与 OMPL 基于OMPL的采样运动规划算法(Sampling-based Motion Planning) yaked： 在qt下编写基于KUKA youbot API的程序 用ROS控制KUKA youbot的5自由度机械臂和夹子 给KUKA youbot机械臂添加dynamic reconfig Actionlib与KUKA youbot机械臂 利用rqt_plot与matlab分析KUKA youbot的joint_states信息 KUKA youbot机械臂与Moveit工具包（1） KUKA youbot机械臂与Moveit工具包（2） KUKA youbot机械臂与Moveit工具包（3） Gazebo与ros_control（1）：让模型动起来 Gazebo与ros_control（2）：七自由度机械臂和两轮差速运动小车 Gazebo与ros_control（3）：Moveit输出规划轨迹到Gazebo Gazebo与ros_control（4）：举一反三，实战youBot 邱博士： 使用MoveIt进行运动规划 实例介绍机械臂运动规划及前沿研究方向 邱博士知乎问题回答 创客智造： MoveIt!入门教程系列 四、总结 我在大二的时候了加入西工大舞蹈机器人基地家政组，负责机械臂的软件开发工作。那个时候ROS的版本还是Indigo，MoveIt!用的人还不是很多，RoboCup@Home比赛队伍中用机械臂的还很少。如今接近两年的时间过去了，当我再次打开MoveIt!官网的时候，教程的数量和质量已经不可同日而语了。我相信现在的机器人爱好者或研究者们要比我当初那会儿更容易地学习并掌握机械臂的开发，并能将其应用到解决当今人们所遇到的问题中去。我们正处在人工智能的伟大时代，而机器人作为人工智能技术最为重要的技术载体，需要我们为此付出努力并勇于探索前方未知的道路。最后，我希望这篇文章可以让更多的开发者迈入机械臂开发的大门，并为机械臂的研究发展贡献你们自己的一份力量！ Copyright © 深圳朝闻道智能信息科技有限公司 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-06-02 16:12:07 "},"docs/Tutorial/Advanced/Multi-Robot/":{"url":"docs/Tutorial/Advanced/Multi-Robot/","title":"多机器人","keywords":"","body":"Copyright © 深圳朝闻道智能信息科技有限公司 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-06-02 16:12:07 "},"docs/OpenRE/":{"url":"docs/OpenRE/","title":"OpenRE教程","keywords":"","body":"HandsFree OpenRE OpenRE全称Open Source Robot Embedded Library ， 是一个专门为机器人写的、基于STM32系列微处理器的嵌入式开源库。经过不断优化，开源库变得鲁棒和通用，从而独立于平台成为一个专门为机器人而生的一个嵌入式库。 主要目的是搭建一个专门为机器人服务的嵌入式跨平台软件框架，涵盖底层设备驱动，算法库，通信与操作系统组件等，主要涵盖以下内容： 封装了许多传感器、存储器、输入输出设备的驱动包，并且采用硬件和驱动包隔离的方式，开发者可以轻易的跨平台移植，比如各种伺服设备、数模舵机、直流三相电机、各种传感器、加速计，陀螺仪、磁力计、超声、 GPS、一些交类互 LCD、触摸屏、 flash、 EEPROM、 SD 卡驱动等。 具有已经移植好的操作系统层功能，实时操作系统（ RTOS），图形库（GUI），网络协议（LWIP）， USB 协议，使用者可以根据自己的需求，选择合适的模板进行开发，省去了移植过程的繁琐操作。 具有很多机器人有关的算法库、 PID 控制包、机器人运动坐标变换包、卡尔曼滤波包、矩阵运算包、四元数等。 支持Linux环境下的makefile + QTCreator + armgcc来进行开发 获取OpenRE源码： OpenRE源码 OpenRE库使用makefile + QTCreator + armgcc来进行开发，相信熟悉makefile的都知道它有多方便，至于windows系统的开发者，也是可以配置windows下的makefile + QTCreator + armgcc的环境来开发的，windows下的keil的工程文件也将后续给出。 获取makefile的学习资料：makefile学习资料 在你正式进行OpenRE嵌入式机器人开发之前，你需要准备一些基础知识，例如会使用linux系统，会用git github管理自己的代码，会使用qtcretor，相关学习资料，HandsFre团队会陆续整理给出，详情请看Robotics-Learning Copyright © 深圳朝闻道智能信息科技有限公司 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-06-05 20:22:12 "},"docs/OpenRE/Getting-Started.html":{"url":"docs/OpenRE/Getting-Started.html","title":"开始","keywords":"","body":"OpenRE环境配置 本将介绍如何在ubuntu下，配置OpenRE的开发环境，并烧写测试代码。 安装 关于工具链的配置有两种方式，可以直接用apt-get 安装，如果网速太慢也可以在百度云下载deb包安装。 首先下载最新的代码： git clone https://github.com/HANDS-FREE/OpenRE 方法一: 通过源码安装 (推荐方法，适用于大部分系统) 获取编译工具链的源码 Development_Toolchain ，把下载的源码包放在 OpenRE/5_Development_Toolchain. 访问Github网速快的话也可以直接执行命令下载 cd OpenRE rm -r 5_Development_Toolchain git clone git@github.com:HANDS-FREE/5_Development_Toolchain.git 5_Development_Toolchain 获取到编译工具链的源码 然后一步步执行以下命令，安装好编译工具链。 $ cd 5_Development_Toolchain $ tar -jxvf gcc-arm-none-eabi-5_4-2016q2.tar.bz2 $ tar -jxvf openocd.tar.bz2 $ tar -jxvf stlink.tar.bz2 $ cd openocd/ $ ./configure $ make clean $ make $ cd ../stlink/ $ make clean $ make $ cd ../ $ sudo usermod -a -G dialout $USER $ sudo apt-get install lib32ncurses5 libtool libusb-1.0 libftdi-dev python python-serial python-empy libpython2.7:i386 $ sudo apt-get remove modemmanager 方法二: 通过deb包安装 （在有些系统上会出问题） $ sudo add-apt-repository ppa:terry.guo/gcc-arm-embedded $ sudo apt-get update $ sudo apt-get install openocd gcc-arm-none-eabi $ sudo usermod -a -G dialout $USER $ sudo apt-get install lib32ncurses5 libtool libusb-1.0 libftdi-dev python python-serial python-empy libpython2.7:i386 $ sudo apt-get remove modemmanager 代码编译与烧写预备 HandsFree目前有几款不同的主控器，比如用于Stone机器人的control_unit_v2，和用于Mini机器人的control_unit_mini，用jlink烧写时，由于不同的电路板外部晶振频率可能不一样，所以把A板的固件烧到B板就可能导致死机和芯片死锁，板子程序无法跑并且下一次烧写的时候就烧不进了，当出现这种情况的时候，解决方法就是按下板子的复位键(按住不动)，运行烧写指令，一两秒后，松开复位键，就能烧写进去了。 为了确保你不会烧写错误，你先确保每个工程的makefile文件和你的板子是匹配的。这里先介绍每个工程的makefile怎么设置，下一篇会详细介绍整个库的makefile。 一个工程的makefile示例： ######################################define project name, board type, and path #####ROBOT_MODEL : null mini stone stone_v2 stone_v3 stone_v3_omni giraffe virtual ROBOT_MODEL ?= stone_v3 #####BOARD_TYPE: openre_board_mini openre_board_v2 BOARD_TYPE ?= openre_board_v2 #####project name PROJECT = robot_$(ROBOT_MODEL)_$(BOARD_TYPE) TOP_PATH = ../../../.. #############################################################parameters #####BOOTLOADER : enable disable BOOTLOADER_MODE ?= disable ##########################################################################source CXX_SRC += ../src/main.cpp #Includes INCDIR += -I. -I../src/ #########################################################################package #PAKG: common robot_abstract math imu ..... PAKG = common robot_abstract math imu motor sbus_ppm servo \\ robot_control hf_link tf #OS_MODULE: UCOSII UCOSIII GUI FAT OS_MODULE = #LIB_MODULE: EIGEN MATRIX etc THIRDPARTY_MODULE = ###################################################################include rules include $(TOP_PATH)/0_Project/makefile/compiler.mk 等号左边的是变量，等号右边的是变量值，#是注释行，注释后面部分是变量的可选值。接下来介绍每一个变量的含义。 ROBOT_MODEL：是使用的机器人的型号，可选值是HandsFree发布的几款机器人，（mini、stone、stone_v2、stone_v3、stone_v3_omni、giraffe, null代表本工程和机器人对象无关，在跑OpenRE示例教程程序的时候会使用到null，virtual代表使用一个虚拟半物理仿真模型，OpenRE内部会虚拟出电机模型和一个差速机器人，内部的运动学和里程计的结算都是用内部虚拟的半物理模型实现的，在调试上位机的时候经常用到virtual）。 BOARD_TYPE：主控电路板型号，可选值是HandsFree的几款主控电路板（目前是两款，openre_board_mini、openre_board_v2）。 BOOTLOADER_MODE：BOOTLOADER模式可以让用户直接从串口下载程序，如果disable就需要用jlink下载。目前默认disable。 PAKG：代表本程序所需要使用到的功能包，在简单测试代码里，只用到了common包。在机器人工程实现代码里，用到了就相对较多了。如果不是自己开发程序，该部分内容一般不做修改。 OS_MODULE：操作系统的模式，目前支持UCOSII、UCOSIII。如果裸跑单片机程序，就空着不填。 THIRDPARTY_MODULE：第三方库的选择，比如矩阵库之类的，如果使用到就在这里填上对应的第三方库名称。 在正式烧写前，请确保你之前的makefile都配置对了，主要是ROBOT_MODEL，BOARD_TYPE这两个变量，如若配置不对，将有可能发生芯片死锁，如果不慎发生死锁，下一次烧写的之前先按住复位键，烧写过程中松开复位键即可解锁。 高危操作提示：以下正式开始编译烧写OpenRE，请确保你打算学习底层嵌入式的开发，HandsFree出厂时都已经烧写好了对应的机器人的固件，以下的学习过程将会覆盖掉出厂程序，请慎重操作。 烧写一个流水灯的代码测试 cd OpenRE/0_Project/examples/handsfree_simple_app/linux 按照上一步修改makefile。 插上jlink同时用usb为板子供电。 接着编译： make clean make 最后烧录： make burn 烧写成功的现象是，板子上的led灯持续闪烁。 如果使用的是STLink，而不是官方配套的Jlink,则需要在make burn之前更改0_Project/makefile/flash.mk 如下: ifeq \"$(strip $(BOOTLOADER_MODE))\" \"enable\" BURN_TYPE = usbttl_bootloader_upload else # (stlink/swd/jlink)_(stlink/openocd)_flash \"device\"_\"driver\"_flash BURN_TYPE = swd_openocd_flash DEBUG_TYPE = swd_openocd_debug ERASE_TYPE = swd_openocd_erase endif 改成: ifeq \"$(strip $(BOOTLOADER_MODE))\" \"enable\" BURN_TYPE = usbttl_bootloader_upload else # (stlink/swd/jlink)_(stlink/openocd)_flash \"device\"_\"driver\"_flash BURN_TYPE = stlink_openocd_flash DEBUG_TYPE = stlink_openocd_debug ERASE_TYPE = stlink_openocd_erase endif （注：如果是重复烧录同一份代码，从第二遍开始就可以省去make clean和make步骤，直接make burn。但是如果两次烧录之间，有.h头文件被修改，就要先make clean，再make，最终make burn。） 烧写机器人的固件程序 固件程序有两个版本的,分别是有操作系统版和裸机版本的,裸机版本是稳定版,操作系统版经过测试也是可以正常使用的.如果你不懂,那么推荐使用裸机版本. 裸机版: 0_Project/firmware/handsfree_wheel_robot操作系统版: 0_Project/firmware/handsfree_wheel_robot_ucosIII 烧写方法和上面一样,值得注意的是,要首先更改Makefile,选择不同的机器人与主控的方式 主要就是修改如下两个变量: #####ROBOT_MODEL : null mini stone stone_v2 stone_v3 stone_v3_omni giraffe virtual ROBOT_MODEL ?= stone_v3 #####BOARD_TYPE: openre_board_mini openre_board_v2 BOARD_TYPE ?= openre_board_v2 一个是选择电路板的型号，一个是选择机器人的型号。可选项在makefile里面都以注释的形式标示出来了。Stone , Giraffe系列机器人平台使用的是openre_board_v2控制器, Mini机器人使用的是openre_board_mini。 这两个变量是必须要选对的,否则会出现意外,比如死锁控制器,或者烧错机器人的代码,导致运动控制不正常，如果不慎发生死锁，下一次烧写的之前先按住复位键，烧写过程中松开复位键即可解锁。 （注：非嵌入式开发者只需看到这里即可，想深入开发OpenRE的可以继续研究后面的OpenRE教程） Copyright © 深圳朝闻道智能信息科技有限公司 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-08-25 18:22:58 "},"docs/OpenRE/Architecture.html":{"url":"docs/OpenRE/Architecture.html","title":"架构介绍","keywords":"","body":"架构介绍 Makefile详解 每个工程都有一个自己的makefile文件（已经在上文讲解过），并且都include了顶层目录下的compiler_config.mk，而compiler_config.mk文件又包含了其它的.mk文件。 这里主要介绍以下几个重要的.mk文件，看懂这几个文件，自己DIY就完全不是问题。 compiler_config.mk: 这个文件除了去包含其它几个.mk之外，还定义了编译的规则，一句话来说，就是定义合适的规则，按照合适的编译流程，编译出.elf文件并且转化成可供烧录的.hex 和 .bin固件，懂makefile的应该是秒懂啦。 重要代码： ifeq \"$(strip $(BOOTLOADER_MODE))\" \"enable\" DDEFS += -DBOOTLOADER_ENABLE endif 解析BootLoader使能情况，同时定义全局宏表征使能失能。 ARMGCC = $(TOP_PATH)/5_Development_Toolchain/gcc-arm-none-eabi-5_4-2016q2/bin/arm-none-eabi-gcc ifeq ($(ARMGCC),$(wildcard $(ARMGCC))) CCPREFIX ?= $(TOP_PATH)/5_Development_Toolchain/gcc-arm-none-eabi-5_4-2016q2/bin/arm-none-eabi- else CCPREFIX ?= arm-none-eabi- endif 在指定目录下寻找编译器，如果没有找到，就启用电脑里安装的编译器。主要是方便内部开发人员的，对大家来说可能没啥用。OPT += -O0 ARMGCC交叉编译的优化等级，可选参数为0、1、2、s建议在debug时候启用0级优化，这样能解决程序很多的潜在问题，编译成功之后启用s级优化，缩小编译后产生的文件大小。 ifeq \"$(strip $(CPU_TYPE))\" \"STM32F1\" FPU_STATE == disable endif ifeq \"$(strip $(CPU_TYPE))\" \"STM32F4\" FPU_STATE == enable endif ifeq \"$(strip $(FPU_STATE))\" \"enable\" OPT += -mfloat-abi=hard OPT += -mfpu=fpv4-sp-d16 endif 根据芯片型号，决定是否启用FPU（浮点运算单元）。再根据是否使能FPU选择是否使用硬件浮点数等其他对应的编译选项。 system_para.mk: 这个文件主要是电路板硬件资源分配的参数设置文件。目前主要就是解决通信端口的资源分配。 ifeq \"$(strip $(BOARD_TYPE))\" \"control_unit_mini\" DEBUG_PRINTF_INTERFACE ?= usart_interface_4 PC_INTERFACE ?= usart_interface_1 RADIO_INTERFACE ?= usart_interface_4 endif 开头的三段代码是一个功能，就是根据当前电路板的型号（已经在顶层的makefile确定），设置具体的硬件资源分配，上面这段代码的含义是，用串口4作为debug的通信口，串口1作为pc端和主控板的通信口，串口4同时还作为主控与遥控器的通信口。 在这之后的内容，就是根据之前确定的参数，设置全局宏定义，传入到程序中去。 board.mk： ifeq \"$(strip $(BOARD_TYPE))\" \"control_unit_mini\" DDEFS += -DCONTROL_UNIT_MINI -DSTM32F10X DDEFS += -DHSE_VALUE=8000000 -DUSE_STDPERIPH_DRIVER MCU ?= cortex-m3 CPU_TYPE ?= STM32F1 BOARD_ABSTRACT += $(TOP_PATH)/1_Processor/BoardAbstract/control_unit_mini.cpp endif package.mk: CXX_SRC+=$(foreachn,$(PAKG),$(wildcard$(PACKAGE_PATH)/$(n)/* .cpp)) 就是对makefile的PAKG变量进行解析，只要是依赖的包，就包含其源文件和路径。 基于OpenRE和HandsFree主控编写机器人程序 Copyright © 深圳朝闻道智能信息科技有限公司 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-06-02 16:12:07 "},"docs/OpenRE/Develop.html":{"url":"docs/OpenRE/Develop.html","title":"开发","keywords":"","body":"OpenRE实战 代码框架介绍 OpenRE框架图 OpenRE的代码由底层到上层主要分为底层接口函数库、常用外设驱动库、OS库、机器人对象的抽象库、第三方库的移植等。下面对每每类函数库做简单介绍。 底层接口函数库在官方固件库的基础上，将对GPIO、定时器、编码器、USART、CAN、IIC、SPI、ADC和PWM等底层资源的操作进一步进行封装。 常用外设驱动库根据官方固件库，对常用的外设提供驱动，例如电机控制、舵机控制、LCD屏幕驱动、GPS模块解码、航模遥控器的解码和IMU的数据处理等。 OS库开发的应用程序包含裸跑程序版本和有操作系统版本，该库包含ucos操作系统的相关文件。 机器人对象的抽象库对移动底盘模型的抽象，包括差分底盘、4轮麦轮底盘和3轮全向轮底盘等。 第三方库的移植移植的第三方库，包括Dobot机械臂库，Eigen3和Matrix矩阵库。 第三方主控的移植 OpenRE是一个开源机器人嵌入式系统。为了让更多的机器人爱好者能够使用到它，我们在这里推出将OpenRE移植到第三方主控（非HandsFree出品的主控）的教程。 很多机器人爱好者在接触到OpenRE的时候会有这样的疑问，我有自己的机器人，我有自己的嵌入式主控，可是我想用OpenRE进行开发，我该怎么办呢？关于这个问题，首先，我们要将OpenRE移植到你自己的主控上去，当一切调试顺利之后，参照教程 架构介绍——基于OpenRE和HandsFree主控编写机器人程序 ，即可让OpenRE运行在自己的机器人上。 接下来，我们就开始第三方主控移植之旅。 在代码框架介绍一节里，大家应该已经掌握到，OpenRE代码按照文件夹的编排可以分为四部分：工程文件、主控描述文件、功能包文件、操作系统文件和第三方库文件。 操作系统文件是服务于Ucos操作系统的。 第三方库文件是我们在工程中实现某些特定功能时调用的别人已经写好的库. 我们可以暂时将这两份文件放在一边。剩下的三个文件中， 主控描述文件是最底层的，它包含了所有与电路板最底层操作相关的函数实现，这些底层驱动函数将大量地在工程文件和功能包文件中被调用。 换句话说，当我们想将OpenRE移植到自己的电路板上时，我们只要完成好主控描述文件的编写，让其对外暴露的API与原先的一致，就不需要对工程文件夹和功能包文件夹做任何修改，OpenRE也就成功移植到第三方主控了。 接下来我们详细剖析一下主控描述文件（1_Processor），主要包含三部分： BoardAbstract： 包含一个board_abstract父类和board子类。board_abstract类是顶层的板级抽象类，它留出了所有对电路板操作的API接口，但是考虑到不同的板子硬件设计不一样，所以在某些可能出现不同的地方，我们使用了虚函数，再用每块板子对应的board子类去继承board_abstract类并将虚函数具体实现。 每一块板子都将有一个control_unit_xxx.cpp（也就是board子类具体实现的地方）与之对应，这些cpp文件种包含了led初始化、蜂鸣器初始化、电机接口初始化、电机使能失能、ADC初始化等。大家可以发现，这些操作都需要与具体的电路板的硬件设计所对应，比如LED具体对应哪个IO口，这是因板而异的，所以我们需要在子类去对应着实现。 值得注意的是不同的control_unit_xxx.cpp都使用的同一个board.h头文件，这就保证了对外API接口的一致，至于在某工程中到底是哪个control_unit_xxx.cpp与board.h关联起来，取决于board.mk的编写，感兴趣的可以往上翻到 4.2Makefile 详解再看一下。 Interupt： 这部分就是中断处理函数的描述，应该不需要做修改。 6个串口中断函数（F1的话是5个）不断的将串口收到的数据压入各自的队列； 一个主中断函数，不断的在计时，用于while(1)中的分频操作； 一个异常中断，单片机发生异常后会在这里利用蜂鸣器报警。 STM32F4/STM32F1： 这里面使我们编写好的BSPLIB，里面把单片机各种底层功能都打包实现了，可以直接调用。 由于确定型号的单片机的IO的资源都是固定的，比如F1的串口1在没有重映射的情况下一直都是PA9、PA10，所以该部分文件也不需要改动。 综上所述，移植OpenRE到第三方主控的流程如下： 新建一个control_unit_xxx.cpp（xxx是你的电路板的名称）。 仿照着现有的control_unit_v2.cpp将所有函数按照你的电路板的特性实现好。函数名不要变，要和board.h能对应起来。 修改board.mk，添加你的电路板的信息如下： ifeq \"$(strip $(BOARD_TYPE))\" \"control_unit_xxx\" DDEFS += -DCONTROL_UNIT_XXX -DSTM32F10X DDEFS += -DHSE_VALUE=8000000 -DUSE_STDPERIPH_DRIVER MCU ?= cortex-m3 CPU_TYPE ?= STM32F1 BOARD_ABSTRACT += $(TOP_PATH)/1_Processor/BoardAbstract/control_unit_xxx.cpp endif 其中的，MCU、CPU_TYPE和“-DSTM32F10X”需要根据你使用的芯片情况改动。 在system_para.mk文件里添加你的电路板的硬件资源分配信息： ifeq \"$(strip $(BOARD_TYPE))\" \"control_unit_xxx\" DEBUG_PRINTF_INTERFACE ?= usart_interface_4 PC_INTERFACE ?= usart_interface_1 RADIO_INTERFACE ?= usart_interface_4 endif 三个参数分别是，debug通信口、pc端和主控通信口、遥控器通信口。你只需要根据自己电路板的硬件资源分配来填写就好。 在工程文件夹的Makefile里面修改第一行：BOARD_TYPE ?= control_unit_xxx 重要功能包讲解 在本小结，我们将单独拎出几个比较重要的软件功能包做一个比较细致的讲解，方便大家了解并学习一些重要功能的实现方法。 common： 该功能包包含了两部分文件，一个是调试接口的printf重映射，用于将printf信息打印到串口调试助手上。还有一个是接收消息的队列实现queue.cpp。我们为每一个串口都创建了一个队列用于接收消息，发送过来的数据会在串口中断处理函数里被压入队列。在程序的其他进程中，读取队列中的数据进行处理。 hf_link: 由于hf_link较为繁琐，我们放在第六章系统讲解。 motor： 该功能包包含电机控制代码motor_control和motor_top。 motor_control中最重要的是pidOrdinaryCall函数和pidSeriesCall函数。 同时我们还创建了motor_control类，实现了通用的PID控制函数，也留出了与具体电路板设计有关的电机初始化，使能等虚拟函数接口，在其子类DC_motor类中具体实现。 pidOrdinaryCall：该函数是单级PID函数，输入参数按顺序包括期望的总里程、实际测量总里程、单位时间内期望里程和单位时间内实际测量里程。函数的输出则是提供给电机的PWM值。 PidSeriesCall：串级PID，感兴趣的同学可以自己去看源码扒一扒，目前我们使用的是单级PID，效果已经可以达到控制的要求了。 motor_top中包含了电机的初始化函数、控制回调函数和电机测试函数。同时我们定义了两个类，一个是直流电机类DC_motor，它继承了motor_control类，将motor_control类中的虚函数具体实现了一下。DC_motor可以看作是对某个具体电机所建立的对象，motor_top类则是将机器人所使用的电机建立一个群组对象，实现对所有电机的统一管理。 motorTopInit：电机初始化函数，输入包括初始化电机的个数、PID控制周期、电机参数和仿真模式使能。 motorTopCall：该函数将在While(1)中以固定频率调用，实现对机器人底盘所有电机的控制。 motorTest：该函数在通常只在电机调试的时候使用，换句话说是内部人员开发的时候测试电机用的。使用方法是将其和motorTopCall放在一起，并屏蔽掉main.c内部的robot_control_p->call();函数。 robot_control： 该功能包包含四部分，分别是机器人的手臂、底盘、云台（头）和机器人的总体控制。 Chassis（底盘）部分，构建了一个底盘类，主要实现了底盘的参数设置，底盘运动的相关数据解算。 setParameters：设置底盘的相关参数，包括底盘的型号、尺寸大小等。这里有个很关键的思想，我们定义了一个父类的TF_robot类，实现机器人速度和电机速度的转换，针对不同的地盘结构，有不同的子类去继承该父类，将父类的速度转换函数实例化。所以这边我们构造了一个父类对象，再根据机器人的底盘型号指向不同的子类，实现代码的封装。 Init：初始化底盘，其实就是调用了上面的函数。 updataGlobalSpeed：将机器人全局速度解算成各个轮子的速度。 updataRobotSpeed：将机器人坐标系速度解算成各个轮子的速度。 call：底盘控制回调函数，根据编码器数据解算里程。 robot_control（机器人总体控制）部分，我们实现了一个机器人控制类，面向的是整个机器人，在统筹手臂、云台（头）和底盘的控制的同时，还负责了hf_link的响应。其中最重要的函数是call和hfLinkNodeEvent。 call：机器人控制回调函数，内部运行了hf_link响应函数和机器人三个部分（手臂、头和底盘）的控制回调函数。该函数在while(1)中以固定频率调用，实现对机器人的控制。 hfLinkNodeEvent：hf_link响应函数。当hf_link将机器人某些数据或参数更新之后，需要做出一些响应。比如hf_link更新了机器人的全局坐标速度之后, receive_package_renew[SET_GLOBAL_SPEED]标志位就会置1，一旦检测到该位的变化，则调用chassis.updataGlobalSpeed();将全局速度解算成每个电机的速度，实现机器人的移动。 Copyright © 深圳朝闻道智能信息科技有限公司 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-06-02 16:12:07 "},"docs/OpenRE/HFLink.html":{"url":"docs/OpenRE/HFLink.html","title":"HFLink通信协议","keywords":"","body":"HFLink详解 该功能包包含了两个类：StateMachine类和HFLink类。 StateMachine类中定义了一个HFMessage结构体，该结构体描述了一个数据包的信息：包括发送者id、接受者id、有用数据长度和数据内容存放数组（容量最大为120字节）。 StateMachine类最重要的是状态机接收函数StateMachine::receiveStates和StateMachine::sendMessage函数。 StateMachine::receiveStates(const unsigned char rx_data)： 该函数会在程序中被循环调用，每次调用，都会将从串口接收消息队列中取出的最新的一个字节的数据传输到函数内部。每次只要传入的数据符合当前状态的要求，状态变量就会自动改变为下一状态，当程序顺利遍历完一遍所有状态之后，预示着收到一个完整可用的数据包，这时候该函数返回1（否则返回0），提示hf_link.cpp中的数据分析函数byteAnalysisCall可以开始进行数据分析。 StateMachine::sendMessage(constHFMessage* txmessage)： 与状态机接收函数相反，该函数是将我们需要上传的数据进行打包发送，确保能够通过上位机的状态机接收函数。该函数的输入参数就是指向待发送数据包的HFMessage类型的指针。 HFLink类继承了StateMachine类，为了使用StateMachine类中的状态机接收函数和数据包发送函数。 同时，在HFLink类中，我们定义了Command枚举变量，里面都是指令类型，在解析数据包的时候，需要根据不同的指令类型做不同处理。 除此之外，因为PC端和主控端共用hflink代码，所以我们使用char型变量hf_link_node_model来区分上下位机（0 slave , 1 master）。 接下来我们来详解HFLink中的函数实现。在这里不贴代码大家可以打开文件hf_link.cpp对照查看。 HFLink::byteAnalysisCall(const unsigned char rx_byte)： 该函数会在while(1)中不断被调用，第一条if判断语句一旦判断正确，预示着状态机接收到一条完整的数据包。接着，会调用HFLink::packageAnalysis进行数据处理。 HFLink::packageAnalysis(void)： 第一次通信前需要上下位机握手，类似于一次通信尝试，告诉对方接下来要开始通信了。下位机调用该函数 sendStruct(SHAKING_HANDS , NULL , 0); 向上位机发送握手请求，上位机收到握手请求后会向下给出答应，下位机收到应答后将shaking_hands_state标志位置1。握手成功。 接下来开始正常通信。 首先，根据状态机中获得的数据包的第一位数据确定指令的类型： commandstate = (Command)rx_message.data[0]; 接着利用switch语句，针对不同的指令类型调用不同的数据处理函数。 数据处理函数主要是两个，setCommandAnalysis 和 readCommandAnalysis。 setCommandAnalysis： 赋值指令分析函数。将上位机发过来的用于设置下位机某些参数或者变量的数据，通过memcpy函数，赋值给下位机对应的变量或参数。 readCommandAnalysis： 信息请求指令分析函数。收到上位机的数据请求消息之后，将下位机的某些变量或者参数，用memcpy函数拆分为多个字节的数据，打包发送给上位机。 HFLink::sendStruct(const Command command_type , unsigned char* p , unsigned short intlen)： 消息发送函数。传入参数包括：指令类别、指向发送内容首地址的指针和发送数据的长度。函数内部主要是填充了HFMessage类型数据的相关信息。 如何自定义通信指令 首先，明确自定义通信指令的作用，涉及到的数据，并且根据通信指令的作用给自己的这条通信指令起个名字。 接着，在hf_link.h中，将该通信指令的名称添加到LAST_COMMAND_FLAG之前。 之后，在hf_link.cpp文件中找到HFLink::packageAnalysis(void)函数，在switch函数里面，仿照之前通信的格式添加新的通信指令解析内容。对于上下位机来讲，都是调用两个函数，setCommandAnalysis和readCommandAnalysis，这两个函数传入的参数都是三个，第一个指令类型，这个不需要自己改，因为是从更外面的函数传进来的，第二个是指向本条通信所涉及到的数据的指针，也就是相关数据的首地址，第三个是数据长度，用sizeof函数就好。如果本条指令不涉及到参数的传递（只是单纯的动作执行指令），就使用NULL指针，数据长度为0。 Copyright © 深圳朝闻道智能信息科技有限公司 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-06-02 16:12:07 "},"docs/Hardware/":{"url":"docs/Hardware/","title":"硬件手册","keywords":"","body":"HandsFree Hardware Copyright © 深圳朝闻道智能信息科技有限公司 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-06-02 16:12:07 "},"docs/Hardware/Devices-Sensors.html":{"url":"docs/Hardware/Devices-Sensors.html","title":"设备和传感器","keywords":"","body":"设备与传感器 本节介绍HandsFree所使用的传感器及设备。将分为视觉、雷达、上层控制器等分别进行介绍。 1,视觉传感器 HandsFree支持的视觉传感器有Xtion Pro，Xtion 2,Kinect 1,Kinect 2，ZED Camera等。我们比较支持大家使用Xtion 2,比较新，只需要使用USB 3.0供电就行。下面就这几款视觉传感器进行简单介绍。首先简单进行一下参数的对比： 属性 Xtion Pro Xtion 2 Kinect 1.0 Kinect 2.0 长(cm) 18 11 28 25 宽(cm) 3.6 3.5 6 8.5 高(cm) 5 3.5 7.5 6.5 景深有效距离(m) 0.8-3.5 0.8-3.5 0.8-4.0 0.5-8.0 有效视角(度) 70 74*52 57*43 70*60 电源/接口 usb2.0 usb3.0 适配器及usb2.0 适配器及usb3.0 官方的基本都是30帧的速度，不同设置可以对图片大小进行改动。Kinect 2.0毛重1.25kg，还要加上1kg的适配器。不是特别建议装载在机器人上。 下面按照推荐顺序进行介绍： 1.1,Xtion 2 Xtion 2是比较新的一款深度摄像头，在机身方面有大幅缩水，性能相比第一代也略有提高。市价在2000元左右，移动开发主要推荐。主要特点有下面几点： 强大的深度感应： 既准确又可扩充的 640 x 480 深度分辨率 高 RGB 分辨率： 高达五百万像素 (2592 x 1944) 的影像分辨率 省电： USB 3.0 耗电量低 尺寸精巧： 体积仅约 110 x 35 x 35mm 适合开发者使用： 兼容于OpenNI 2.2并支持多个操作系统 还有必须要说的是目前这款摄像头对Ubuntu 16.04不太友好，只能接受深度信息，rgb信息连接就会出现问题。在Ubuntu 14.04中，也需要进行一些额外的操作才可以使用。具体安装与使用请参考RGBD摄像头实验 1.2,Kinect v1 Kinect for Xbox 360，简称 Kinect，是由微软开发，应用于Xbox 360 主机的周边设备。它让玩家不需要手持或踩踏控制器，而是使用语音指令或手势来操作 Xbox360 的系统界面。它也能捕捉玩家全身上下的动作，用身体来进行游戏，带给玩家“免控制器的游戏与娱乐体验”。其在2010年11月4日于美国上市，建议售价149美金。Kinect在销售前60天内，卖出八百万部，目前已经申请金氏世界记录，成为全世界销售最快的消费性电子产品。 由于它应用广泛，很多大佬都给开发了相关的驱动，开发起来会简单很多。目前已经停产，但是可以在淘宝上买到二手的，而且价格比较良心加上适配可能也就几百块钱。建议囧困新手先搞一个这个试试，功能基本都能满足。缺点：它需要使用自己的适配器，供电上有一个220v转12v的电源转换器，不可拆卸。如果用到移动机器人上，需要将线剪断，使用HandsFree电源管理模块的12v进行供电。如果只是在固定端使用，就不需要进行改动。我觉得主要原因是Xtion 和Kinect面向人群不一样。Xtion主要面向开发者，按照官方的说法，机器人设计、保全监控、汽车工程或是 3D 扫描等都可以用到。但是Kinect 主要面向是游戏开发，固定在一个位置就行。所以移动的话首选Xtion 2（Xtion Pro能买到的话也可以用），再推荐Kinect v1,Kinect v2不推荐，因为太重了。 使用方法: 首先安装驱动 sudo apt-get install ros-indigo-freenect-* rospack profile 连接摄像头并使用 roslaunch freenect_launch freenect-registered-xyzrgb.launch 1.3,Xtion Pro Xtion Pro是世界首款独家专业PC体感软件开发解决方案，兼容于OPNI NITE中间件的SDK可让体感应用程序及游戏的开发变得简单！ROS对这款摄像头的支持比较好，安装驱动也比较简单。但是！！！已经停产了，基本上已经买不到了，但是这款比较好用，而且重量比较轻。如果能买到，还是很好用的。 使用方法: 首先安装驱动 sudo apt-get install ros-indigo-openni-camera sudo apt-get install ros-indigo-openni-launch sudo apt-get install ros-indigo-openni2-launch 连接摄像头并使用 roslaunch openni2_launch openni2.launch 1.4,Kinect v2 Kinect v2虽然也是比较新的一款，但是是最不推荐的一款。前面也说了，太重了，而且体积巨大，可能在前面列出的参数中比较不出来，那是因为别的还有底座，摄像头其实不大，但是这款就是一个四四方方的大家伙。而且需要一个很重的电源适配器。移动的话，首先它的重心不能太高，然后还要考虑供电，这个跟第一代一样，也是需要把电源线剪了，接到12v上。不可逆。。。但是由于应用广泛，所以对开发者也是比较友好的，但是确实是有点太重了。价格在1400左右，购买时一定要购买适配器套装。 使用方法: 首先安装驱动 在ROS上使用Kinect v2，需要的步骤要多一点，但是也不是很麻烦，在github上跟着install一路安装下去就行。简单翻译一下：1,安装好ROS并配置好环境（已经安装过了就跳过）2,安装libfreenect2,请参照具体安装步骤3,将仓库克隆到本地并编译 cd ~/catkin_ws/src/ git clone https://github.com/code-iai/iai_kinect2.git cd iai_kinect2 rosdep install -r --from-paths . cd ~/catkin_ws catkin_make -DCMAKE_BUILD_TYPE=\"Release\" 连接摄像头并使用 roslaunch kinect2_bridge kinect2_bridge.launch 2,雷达 本节介绍HandsFree支持的二维激光雷达，主要推荐的有Hokuyo系列，rplidar 系列，还有一款入门雷达EAI X4。下面进行简单对比介绍： 属性 Hokuyo URG-04LX rplidar A2 rplidar A1 EAI X4 距离(m) 0.02-5.6 0.15-12 0.12-12 0.12-10 角度(度) 240 360 360 360 角度分辨率(度) 0.36 0.9 * 频率(Hz) 10 5.5 5.5 6-12 误差 3%/m 1%/m 1%/m * 测量频率（次/s） * 8000 8000 5000 价格（￥） 6400 2800 500 500 如果还有其他的需求，请参考ROS官网上其他可用雷达。 2.1,Hokuyo URG-04L/UTM-30Lx HOKUYO公司URG-04LX 2D激光扫描测距产品拥有5.6m, 240°测量范围，DC5V输入(USB接口供电)，100ms扫描时间，可用于机器人避障和位置识别；高精度、高分辨率、宽视场设计给自主导航机器人提供了良好的环境识别能力；紧凑型设计节约了安装空间，低重量、低功耗；不受强光影响，在黑暗中亦能工作；非接触式测量； 毕竟价钱在那摆着，稳定性和精度都有保障。但是价格比较贵，建议在Giraffe上或者Stone上用。角度分辨率这个参数还是比较准的，误差的话，我个人觉得国内这几款产品有些夸大了。所以大车或者精确度要求比较高的话，建议这款雷达。 使用方法: 安装驱动 sudo apt-get install ros-indigo-hokuyo-node 连接雷达并使用 roslaunch handsfree_bringup hokuyo.launch 上面的命令需要安装handsfree的相关软件 2.2,rplidar A2 工作时，RPLIDAR A2 的测距核心将顺时针旋转，实现对周围环境的360度全方位扫描测距检测，从而获得周围环境的轮廓图。采用定制特殊部件，精心设计的内部机械系统，保证优越性能的同时，产品厚度仅为 4 厘米，适合于各类服务机器人。全面改进了内部光学和算法系统， 采样频率高达8000次/秒，让机器人能更快速、精确的建图。摈弃第一代中的皮带传动方式，采用自主设计的无刷电机，大大减小运行时的机械摩擦，运行十分顺畅，几乎没有噪音。借助于无刷电机和光磁融合技术，在7*24小时连续工作情况下，可达5年以上的使用寿命。 总体来说，A2雷达还是比较出色的，小巧灵活，只连接usb偶尔会出现供电不足的情况，额外进行供电会改善很多。建议在stone和Giraffe上使用。 使用方法: 安装驱动 如果下载了handsfree的代码就不需要进行此步骤。参照github上官方给出的驱动安装说明,先下载到一个ros工作空间的src目录下，然后catkin_make。 连接雷达并使用 roslaunch rplidar_ros rplidar.launch 注意，尽量不要用无源usbhub连接雷达，因为电压电流可能达不到要求，虽然显示连接成功，但是会没有雷达信息输出。 2.3,rplidar A1 RPLIDAR A1采用激光三角测距技术，配合自主研发的高速的视觉采集处理机构，可进行每秒8000次以上的测距动作。测距核心顺时针旋转，可实现对周围环境的360度全方位扫描测距检测，从而获得周围环境的轮廓图。通过USB电缆将RPLIDAR与你的计算机进行连接后，即可直接使用，无需任何编码工作。综合无线供电和光通信技术,独创性的设计了光磁融合技术彻底解决了因物理接触磨损导致电气连接失效、激光雷达寿命短的问题。 A1雷达在2017年末进行了设备升级，性能有了大幅度提高，但是相对于A2来说还是有一定差距。首先A2高度更低，更加小巧;第二点，声音更小，还更加美观;第三点，性能方面，距离、分辨率准确度等方面都要好一点。但是用A1来入门还是很不错的。 A1和下面要介绍的EAI X4都是500元左右，笔者推荐A1,A1已经经历了时间的考验，X4是2017年11月推出的。（但是还是要谢谢EAI） 使用方法和A2一样 2.4,EAI X4 EAI X4推出时自称性价比之王，无出其右。因为当时的A1卖999,而且测量频率只有2000次/秒，远低于5000次每秒的X4雷达。谢谢X4是因为它让思岚科技的雷达全都降价还升级。X4雷达测量距离可以达到10m，但是测量频率比升级后的A1要低，只有5000次/s。 应用场景有：自主建图、自动避障、路径规划、教育科研、创客教育和辅助定位等。 使用方法: 安装驱动根据官方给出的ros使用说明,先将其下载到ros工作空间，然后编译，最后对设备进行设置。 连接设备并使用 roslaunch ydlidar lidar_view.launch 3,上层控制器 上层控制器是针对底层stm32控制器的一个相对的称呼，主要是指与各传感器及底层进行通信的上层模块，一般来说，就是tk1/tx1或者工控机。tk1和tx1是基于arm的架构，并行处理和深度学习可能会用到，ROS也提供了相关的安装方法。但是主流还是基于x86的处理器，而且还有其他因素（下面会说），还是会推荐使用我们推荐的套餐中的几款工控机。下面就这两种进行简单介绍。 3.1,工控机 工控机一般都是基于x86架构的，我们在进行了测试之后推荐大家使用下面几款工控机： 属性 高配 中配 低配 CPU i7-7500U i3-6100U N2830 硬盘 240固态 60G 30G 内存 8G 4G 2G 首先这三款工控机我们都是经过测试的，性能都比较好，但是还是要根据不同的机器人来选择，比如mini我们建议使用低配版，Stone我们建议使用中配版和高配，Giraffe我们建议最低使用高配版，或者选择更高配置的工控机，比如带GTX 1060的工控机，Giraffe载重能力和电池都比较好，所以选择余地更多。 以上提到的工控机都使用12v供电，可以直接使用机器人上电源管理系统上的12v接口。 具体安装配置步骤可参考如何使用镜像或者配置环境 3.2,tk1/tx1 NVIDIA Tegra K1是NVIDIA的首款移动处理器，具有与现代桌面GPU相同的高级功能和架构，同时仍然使用移动芯片的低功耗。 因此，Tegra K1允许嵌入式设备使用完全相同的CUDA代码，这些代码也可以在桌面GPU（超过100,000个开发人员使用）上运行，具有与桌面相似的GPU加速性能水平。除了四核2.3GHz ARM Cortex-A15 CPU和革命性的Tegra K1 GPU，Jetson TK1板还包括与Raspberry Pi类似的功能，还包括一些面向PC的功能，如SATA，迷你PCIe和风扇，可连续 在繁重的工作量下运作. NVIDIA Jetson TX1是NVIDIA第二代嵌入式平台开发者套件，是智能无人机、机器人理想的嵌入式解决方案。内建256个CUDA核心的NVIDIA Maxwell GPU，64位ARM A57 CPU，4GB LPDDR4内存、16GB闪存、蓝牙、802.11ac Wi-Fi模块和千兆以太网卡，运行Linux for Tegra操作系统。 tk1主要有两个缺点，所以我们不建议使用： 1,易损坏，我们买的tk1曾经出现了各种各样的问题 2,已停产，停产就意味着未来使用这个进行开发的人越来越少 TX1也是基于ARM架构的，如果有这方面需求可以使用，如果不是很迫切，我们还是建议使用我们测试并提供的工控机，因为有些细节在ARM架构下开发板上不太友好。 配置步骤请参考TK1刷机教程 Copyright © 深圳朝闻道智能信息科技有限公司 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-06-02 16:12:07 "},"docs/Hardware/OpenRE-Board.html":{"url":"docs/Hardware/OpenRE-Board.html","title":"主控制器","keywords":"","body":"OpenRE Board 使用手册 OpenRE Board 是HandsFree Team根据HandsFree开源项目的硬件标准开发的一款的运动控制器，是HandsFree所有平台的重要组成部分，可以应用于轮式机器人，人形机器人，平衡车，旋翼和固定翼的开发。 由于HandsFree建立了一个自己的机械，电路，嵌入式标准，所以OpenRE Board还会支持HandsFree Team后续开发的软硬件。你既可以用这款控制器进行自主开发，也可以使用HandsFree嵌入式软件库OpenRE来开发，OpenRE提供了足够多的底层驱动代码和机器人代码库，以及代码的使用手册和测试案例，而且所有源码都是开源的。 下载OpenRE源码： OpenRE源码 学习OpenRE： OpenRE教程 OpenRE Board 使用手册 OpenRE Board 控制器是在第一代主控基础上发展而来一款多用控制器，不仅仅可以用于控制小车等地面移动平台，也可以用于飞行器的控制，在吸取第一代主控的优点和不足的基础上进行改造，设计了自己的核心板，并且将众多传感器集成在核心板上，主控板支持7~12V的电源输入。 专业级机器人控制器 OpenRE Board 板载资源 关键特征 168MHZ STM32F407 Cortex M4 板载三轴陀螺仪，三轴加速计，气压计，三轴磁力计。 10PWM输入输出。 USBTTL, USB，microSD卡。 支持机型： 两轮平衡车，两轮差移动平台，三轮全向平台，四轮差速平台，四轮麦克纳姆轮全向平台，数字舵机人形，固定翼，四六八轴旋翼飞行器等。 处理器 32bit STM32F407 VGT6 Cortex M4 core with FPU 168MHZ 192KB SRAM 1M Flash 封装类型：LQFP, 引脚个数：100 板载传感器 MPU6050 6轴运动处理 ， 加速计陀螺仪。 MEAS MS5611高精度气压计。 3-轴数字罗盘IC HMC5883L 板载IC 大容量IIC快速存储器512KB EEPROM 专用ADC基准电压芯片LM4030A，电压采样精度高，可接固定翼用的空速计。 板载5V，3A大电流稳压IC。 集成CP2102 USB串口芯片。 集成VP230 CAN控制芯片。 集成三态门IC，用于数字舵机通信 板载多路电源保护器件，防反接，防过流，抵抗静电，支持多路USB和电源同时供电。 板载SBUS反相器电路，支持遥控器信号读取。 板载接口 四个电机控制以及编码器接口，支持常见类型的机器人平台控制。 10路PWM输出，可同时作为输入，用于搭建多轴飞行器或者舵机控制。 三路串口，USART2 UART4 USART6。 一路USB串口 USART1。 一个USB主从机接口。 一个microSD卡接口。 一路SBUS遥控器采集接口，用于采集航模遥控器的信号。 一路PPM遥控器采集接口，用于采集航模遥控器的信号，PPM接口还可用于扩展空速计。 一路数字舵机控制接口,支持AX12系列的数字舵机。 一个GPS接口，支持外部IIC陀螺仪和磁力计，兼容PX4接口。 一路CAN总线接口，可用于通信组网。 一路IIC接口，可用于扩展外部惯导传感器或者超声波等。 一路SPI接口。 除了以上，板载还有多个led显示，一个蜂鸣器，SWD烧写，复位电路等，电源电压采集电路等。 电源支持7~28V输入。 总结 HandsFree控制器，板载资源十分丰富，下料十足，可满足常见形态机器人研究需求，同时不惜成本，尽量选择稳定可靠的接口和IC，光是一个ADC基准电压的芯片就十几块钱，MOLEX接口也是选用昂贵的自锁接口，这主要是因为HandsFree团队本身也是使用这款控制器进行研究开发的，在很多细节方面考虑也是为了满足自己需求。 同时HandsFree团队开放了OpenRE嵌入式机器人库，用户可以方便的在此库的基础上进行应用程序构建。OpenRE支持在linux环境下的开发，大大方便了ROS开发者和不懂嵌入式的机器人开发者。 OpenRE Board Mini使用手册 OpenRE Board Mini 是HandsFree Team根据HandsFree开源项目的硬件标准开发的一款的运动控制器，是HandsFree Mini移动平台的重要组成部分。Mini移动平台是HandsFree团队专为广大机器人学生爱好者开发的一款助学平台，价格低廉，性价比超高，麻雀虽小五脏俱全，Mini移动平台同样可以用来进行移动导航和视觉开发。我们根据Mini移动平台的特点将驱动集成在Mini控制器上。同时增加了蓝牙模块和集成的MPU6050。其功能齐全性价比超高，配合方便使用的嵌入式代码受到广大学生用户的喜爱。 OpenRE Board Mini 控制器支持12V电源输入，同时允许转接电源，带有两个12V电源转接口，允许转接到其他设备使用。Mini控制板上设置一个了电源开关，接通12V电源后按下开关主控器便开始工作，此时电源指示灯会变亮。控制板四周接有4个电机接口，两个串口，一个SPI接口，一个串口usb接口，一个SWD接口，一个can总线接口。同时控制板上集成了两块电机驱动（支持驱动四个电机），一块MPU6050，一个蓝牙，极大的方便了用户进行开发。 高性价比机器人控制器 OpenRE_Board_Mini 板载资源 板载资源 STM32F103芯片 mpu6050加速计陀螺仪 4路电机控制接口：支持HandsFree Team开发的电机驱动，可用于搭载HandsFree平衡车，HandsFree Mini移动平台。 1路can总线：板载1个can接口，可用于通信，或者扩展hands free imu 高精度单轴陀螺仪 1路spi接口 1路双座USB母座接口：提供转接5V电源 2路串口接口： usart4 uart5 一个usb串口：采用ft232 usb 串口芯片 usart4，可usb线升级固件和通信 1个swd程序烧写接口 1个蓝牙 Copyright © 深圳朝闻道智能信息科技有限公司 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-06-02 16:12:07 "},"docs/Hardware/Power-Manager.html":{"url":"docs/Hardware/Power-Manager.html","title":"电源管理系统","keywords":"","body":"HandsFree Power Manager 使用手册 简介 HandsFree Power Manager是HandsFree Team根据HandsFree开源项目的硬件标准设计的一款电源分配板，附带多路开关和多路电源转换功能，满足机器人多样的电力需求。支持常用的TX1/2，TK1，MiniPC，树莓派，Kinect1/2，HOKUYOU雷达，工控机，笔记本等设备供电，同时还支持HandsFree机器人的电机驱动，云台，机械臂,升降等结构的供电，还自带一路急停电源输出。配合大容量电池可以为机器提供集成供电方案。 集成供电方案 HandsFree 在中型及以上的移动平台上采用集成化的供电方案，这是为了简化机器人的开发，同时方便开发者进行多种形式自定义需求。在电源板上有数量众多的电源接口，提供多种不同的电压，可以给各种形式的设备进行供电。同时我们统一定义了不同接口和电压的标准，保证了设备的安全。 板载资源 电源电压 12V ～ 36V USB5V/2A x 2 , 可用于给树莓派，Pcduino等设备供电。 12V/3A x 4 , 可用于给TK1, Kinect1/2，Hokuyo 雷达等供电。 19V/3A x 3 , 总功率57W以上,可用于给笔记本,工控机等设备供电。 电源扩展/(>10A) x 5 ,电压等于电池电压，其中包含一路急停接口, 可用于给底盘, HandsFree机械臂等供电。 HandsFree自带的设备都将支持电源分配板。 购买HandsFree平台将附赠电源分配板的转接线, 用户可以方便的给常用设备供电, 比如PC，TK1,TX1/2等。 Copyright © 深圳朝闻道智能信息科技有限公司 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-06-02 16:12:07 "},"docs/Hardware/Module.html":{"url":"docs/Hardware/Module.html","title":"电路模块","keywords":"","body":"HandsFree 相关电路模块介绍 Bluetooth USART HandsFree Bluetooth USART 是HandsFree Team根据Hands Free开源项目的硬件标准开发的一个串口转蓝牙模块,Bluetooth_USART还会支持HandsFree Team后续开发的软硬件,以及APP，上位机等。 板载资源 蓝牙4.0芯片 led 3.3V稳压芯片 5针串口接口 USBTTL HandsFree USBTTL 是HandsFree Team根据Hands Free开源项目的硬件标准开发的一个USB转串口模块,USBTTL还会支持HandsFree Team后续开发的软硬件。 实物图： 板载资源： FT232RL芯片 三个LED USB micro接口 5针串口 Copyright © 深圳朝闻道智能信息科技有限公司 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-06-02 16:12:07 "},"docs/Courses/":{"url":"docs/Courses/","title":"附录一:机器人课程","keywords":"","body":"Copyright © 深圳朝闻道智能信息科技有限公司 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-06-02 16:12:07 "},"docs/Courses/Robotics-Learning.html":{"url":"docs/Courses/Robotics-Learning.html","title":"机器人学习规划","keywords":"","body":"机器人入门 概述 机器人是一个复杂系统，对理论和工程知识的要求综合度是非常高的，如果你没有足够的激情，不断学习的心态，独立解决困难的决心，建议你还是不要入这个神坑。 即使你有上述的基本素质，机器人也不是想玩就能玩的，至少不是你有钱买个平台你就有能力玩起来的， 虽然我自己也很菜， 但是我还是得给新手指指方向。我觉得如果你能满足以下条件再开始你的HandsFree开发之旅会比较好一点。 编程功底要够好 编程就和学英语一样，需要你在平时的科研进程中不断学习和练习，没有最强只有更强，不懂计算机语言永远别想踏进IT世界，而然编程语言多如牛毛，不同领域的软件工程师有不同的选择，也很难划定界限。如果你以后要搞机器人系统，机器学习，计算机视觉 ，我建议要掌握好C++ 和 python ， 特别是如果你是走工程路线的话，那么C++一定要非常好，这也是学ROS HandsFree 必过的一关。具体可以参考C++学习规划。 对机器人的整体系统有一定的了解 虽然你可能只是一个 SLAM，计算机视觉，机器学习等局部问题的研究者，但是如果你要玩整机那就得对整体系统，从机械结构到机器人学，电路，嵌入式等有一些最基本的了解。这本书可以帮你入门，请确保你可以看懂： 自主移动机器人导论 （美）西格沃特（Siegwart,R.），（美）诺巴克什（Nourbakhsh,I.R.） 学习ROS ROS 可能是大部分人入门的工具，请你在有一定基本了解的前提下再买我们的平台，否则你可能会失望，除非你懂机器人且不用 ROS 来构建你的机器人系统。ROS学习请参考 ROS 学习规划 C++学习规划 最基本的是要能看懂 stephen prata 的《C++ Primer Plus》 ，另外《C++ 标准程序库》可供参考，相关资料可以参考HandsFree 百度云提供的编程学习资料 对C++语法和编程有一定基础之后，你也许已经写过很多小程序了，接下来你需要培养你看大工程代码的感觉，就和学英语一样，掌握语法和句子之后，看看英语文章或者小说会增加你的阅读能力，以下是个人建议 掌握几个知名的库，比如qt，opencv ， boost等 ， 可以参考 qt 学习教程 通过工程实战来提升运用能力，比如看一些常用的ROS的包或者仔细研读HandsFree的代码，也可以根据自己的研究方向去学习相关的开源工程，通过改开源的代码实现一些自定义的应用，久而久之，你就有能力独立的搭建大工程了。 在这个过程中，你对编程会有一些自己的体会，并慢慢的需要看一些编程思想，编程风格之类的书，并需要对C++有更深的理解，推荐学习google 和 ros 的编程风格 ，阅读《(More)Effective C++》、《(More)Exceptional C++》、《Effective STL》及《C++编程规范》提升对C++的理解，可以参考HandsFree百度云 编程学习资料 提供的相关资料。 在以上过程中，会发现那些优秀的工程比如ROS Qt 等就像精美的艺术品，娴熟的语法运用，优美统一的风格，严谨紧凑的逻辑，这除了说明他们对自己领域的知识看的非常透彻外，也说明他们驾驭编程已经上升到编程哲学境界了，虽然这辈子我们都难成为这种高手，但是有必要关注一下高手的世界。我们可以通过学习设计模式 和 泛型编程，来帮助我们理解如何构建大的软件工程。 ROS 学习规划 关于ROS的学习，现在网上已经有很多中文教程了 , 可以参考 易科机器人，RosClub，最重要的是要学会如何使用ros wiki。 HandsFree不是ROS基础教程，只适合有一定ROS基础的同学深入学习研究ROS，或者基于HandsFree研究机器人相关话题比如SLAM ， 机械臂控制，多机器人协同。如果你要开始使用或者购买HandsFree平台，请确保你已经满足以下条件。 请确保你看懂beginner level 的教程，如果你的经验还不够多，请多看几遍。 请确保你看过比较正式的书籍，随便一本你看懂了就行：比如你已经大概看懂 ros by example 1 indigo 前 8 章 另外我再推荐一个国外的 ROS 入门 ppt： http://u.cs.biu.ac.il/~yehoshr1/89-685/ 相关学习资料可以看HandsFree百度云 ，如果你以上条件你都 ok， 那么入手实物机器人就比较科学了，当然你要知道的远不止这些，很多细节的问题和工程经验是列不完的。 相关学习资源 https://hands-free.github.io/ http://blog.exbot.net/archives/2790 https://zhuanlan.zhihu.com/p/22763273 http://blog.exbot.net/archives/1129 http://www.guyuehome.com/ 需要的工程素质 学会使用google，翻墙，查资料 对机器人系统有一定认识，机械结构，电路，嵌入式，传感器等 学会用markdown来编辑文档，这是我们团队的通用文档格式之一 会用git，github 来管理代码，与人合作开发 软件开发人员最好熟悉使用linux，学会makefile cmake linux_shell xml 等常用的脚本或标签语言 参考学习方向 移动机器人基础 了解机器人的定义，各种不同形态的机器人：无人机，地面机器人，水下航行器 以及其子分类。 着重了解地面机器人中的轮式移动机器人，了解不同结构的移动机器人：差速，全向，平衡车，汽车形态的等等 了解移动机器人的历史 ， 组成和功能：云台，地盘，机械臂，升降杆等 移动机器人的各种伺服结构和驱动方法 移动机器人的各种传感器的作用，以及整个移动机器人系统是如何工作的，如何实现自主。 各个组别的学习可以参考HandsFree NWPU Club的分组学习计划 Copyright © 深圳朝闻道智能信息科技有限公司 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-06-05 20:22:02 "},"docs/FAQ/":{"url":"docs/FAQ/","title":"常见问题解决方法","keywords":"","body":"本章介绍了常见的问题及解决方法（答案）。 串口USB插拔损坏解决方案 获取工控机IP地址的方案 运行roslaunch handsfree_hw handsfree_hw.launch出现问题的解决方案 在用make和make burn指令编译烧录OpenRE代码的时候出现错误 机器人滴滴滴报警解决方案 机器人安装详细步骤 如何配置环境 Copyright © 深圳朝闻道智能信息科技有限公司 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-06-02 16:12:07 "},"docs/FAQ/when-usb-was-broken.html":{"url":"docs/FAQ/when-usb-was-broken.html","title":"把电路板USB插坏了怎么办？","keywords":"","body":"串口USB插拔损坏解决方案 OpenRE的灵活性之一体现在对硬件资源的快速简单配置。我们的主控板除了串口一作为HFLink通信的默认端口外还预留了其他的串口。如果串口USB插拔损坏，则表示串口一的硬件损坏，此时可以转而使用其他未被占用的预留串口。 具体步骤如下： 更改makefile 如果使用的是control_unit_v2： 1.进入文件夹.../OpenRE/0_Project/makefile路径下，打开configuration.mk文件。 2.找到如下代码： ifeq \"$(strip $(BOARD_TYPE))\" \"control_unit_v2\" select the usartx for board debug info printf : usart_interface_x,usb_slave DEBUG_PRINTF_INTERFACE ?= usart_interface_1 select the usartxfor pc communications (hf_link) :usart_interface_x,usb_slave PC_INTERFACE ?= usart_interface_1 select the usartx for remote control (hf_link) : usart_interface_x RADIO_INTERFACE ?= usart_interface_4 endif \"DEBUG_PRINTF_INTERFACE\"就是调试使用的串口号，目前是串口1。 \"PC_INTERFACE\"就是HFLink，也即上下位机通信使用的串口号，目前也是串口1。 串口USB插拔损坏，表示串口一现在无法正常使用。只需要在这里将 DEBUG_PRINTF_INTERFACE ?= usart_interface_1 PC_INTERFACE ?= usart_interface_1 修改为 DEBUG_PRINTF_INTERFACE ?= usart_interface_6 PC_INTERFACE ?= usart_interface_6 即可。 注意：串口2被SBUS占用，V2主控板上只剩下串口6空闲。 如果使用的是control_unit_mini： 1.进入文件夹.../OpenRE/0_Project/makefile路径下，打开system_para.mk文件。 2.找到如下代码： ifeq \"$(strip $(BOARD_TYPE))\" \"control_unit_mini\" select the usartx for board debug info printf : usart_interface_x,usb_slave DEBUG_PRINTF_INTERFACE ?= usart_interface_4 select the usartxfor pc communications (hf_link) : usart_interface_x,usb_slave PC_INTERFACE ?= usart_interface_4 select the usartx for remote control (hf_link) : usart_interface_x RADIO_INTERFACE ?= usart_interface_5 endif DEBUG_PRINTF_INTERFACE就是调试使用的串口号，目前是串口4。 PC_INTERFACE就是HFLink，也即上下位机通信使用的串口号，目前是串口1。 串口USB插拔损坏，表示串口一现在无法正常使用。只需要在这里将 DEBUG_PRINTF_INTERFACE ?= usart_interface_4 PC_INTERFACE ?= usart_interface_4 修改为 DEBUG_PRINTF_INTERFACE ?= usart_interface_5 PC_INTERFACE ?= usart_interface_5 即可。 3.将USB的一端连接电脑，另一端，用我们淘宝店售卖的USB转TTL转接板接到Mini主控板正面的usart4端口上。此时即可正常通信。 连接USB转ttl转接板 当我们要让电脑和串口通信时，我们需要接上一个USB转TTL转接板进行通信，下面以我们售卖的USB转TTL转接板为例进行讲解。 当我们改变了makefile文件后，看我们更改为哪个接口，就用5P molex端子线连接到板子对应的接口。以我们上面所讲的示例来看，control_unit_v2需要接到uart6端口，control_unit_mini需要接到usart4端口。 Copyright © 深圳朝闻道智能信息科技有限公司 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-06-02 16:12:07 "},"docs/FAQ/when-motor-interface-was-broken.html":{"url":"docs/FAQ/when-motor-interface-was-broken.html","title":"把电机接口插坏了怎么办？","keywords":"","body":"电机接口插拔损坏方案 OpenRE的灵活性之一体现在对硬件资源的快速简单配置。我们的主控板拥有四个电机接口，当我们其中某个电机接口插拔损坏后，可以转而使用其他未被占用的预留电机接口。 具体步骤如下： 1. 更改makefile 1.进入文件夹.../OpenRE/0_Project/makefile路径下，打开configuration.mk文件。 2.找到如下代码： ####select the motor interface of the control_unit_board for robot motor id : motor1, motor2, motor3, motor4 ROBOT_MOTOR1 ?= motor_interface_1 #### Tips: this means to map motor_interface_1 on the board to No.1 motor of robot ROBOT_MOTOR2 ?= motor_interface_2 ROBOT_MOTOR3 ?= motor_interface_3 ROBOT_MOTOR4 ?= motor_interface_4 \"ROBOT_MOTOR1\"就是机器人身上的电机1，\"motor_interface_1\"就是板子上的电机接口1，正常情况下，机器人身上的电机ID号，和电路板的ID号一一对应，即机器人电机1（N）接主控板的电机接口1（N）。 如果主控电机接口1（N）插拔损坏，只需把机器人电机连接到其他的主控电机接口上。 假设主控电机接口2被插坏了，那么只需要把机器人电机2插到主控板第3个电机接口上同时修改以下映射关系即可。 ROBOT_MOTOR1 ?= motor_interface_1 ROBOT_MOTOR2 ?= motor_interface_2 修改为 ROBOT_MOTOR1 ?= motor_interface_1 ROBOT_MOTOR2 ?= motor_interface_3 即可。 2. 重新烧写机器人固件 固件目录，OpenRE/0_Project/firmware/handsfree_wheel_robot，烧写方式，请看OpenRE教程。 主控板的电机接口ID编号 当我们如上述在makefile文件中修改了电机的接口后，我们只需要将电机一接到板子上的电机接口三上即可。 control_unit_v2板如上图所示，电机接口在图右的4,5,8,9接口。 control_unit_mini板如上图所示，电机接口在图右的7,8,9,10接口。 机器人的电机ID编号 两轮差速机器人 对于两轮差速机器人而言（mini，stone，giraffe），俯视机器人，雷达方向朝着正前方，那么机器人左边的电机为1号电机，机器人右边的电机为2号电机。 三轮全向机器人 对于三轮全向机器人而言（stone_omni）,俯视机器人，雷达方向朝着正前方，那么机器人正前方电机为1号电机，机器人左边的电机为2号电机，机器人右边的电机为3号电机。 Copyright © 深圳朝闻道智能信息科技有限公司 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-06-25 15:24:31 "},"docs/FAQ/how-to-get-IP.html":{"url":"docs/FAQ/how-to-get-IP.html","title":"如何获取工控机IP地址？","keywords":"","body":"获取工控机IP地址的方案 在进行远程控制之前，我们需要在.bashrc文件里面填写运行Master节点的工控机的IP地址，只有IP地址写对了，两台电脑上的节点才能正常通信。 方案一：工控机上读取 将工控机接上显示器和键盘，打开终端，输入： ifconfig 会显示如下信息 eth0 Link encap:以太网 硬件地址 80:fa:5b:2a:c8:41 inet6 地址: fe80::82fa:5bff:fe2a:c841/64 Scope:Link UP BROADCAST RUNNING MULTICAST MTU:1500 跃点数:1 接收数据包:1711 错误:0 丢弃:1 过载:0 帧数:0 发送数据包:2018 错误:0 丢弃:0 过载:0 载波:0 碰撞:0 发送队列长度:1000 接收字节:605189 (605.1 KB) 发送字节:353539 (353.5 KB) lo Link encap:本地环回 inet 地址:127.0.0.1 掩码:255.0.0.0 inet6 地址: ::1/128 Scope:Host UP LOOPBACK RUNNING MTU:65536 跃点数:1 接收数据包:2027 错误:0 丢弃:0 过载:0 帧数:0 发送数据包:2027 错误:0 丢弃:0 过载:0 载波:0 碰撞:0 发送队列长度:1 接收字节:12736730 (12.7 MB) 发送字节:12736730 (12.7 MB) wlan0 Link encap:以太网 硬件地址 00:1e:64:f0:23:37 inet 地址:10.25.57.81 广播:10.25.63.255 掩码:255.255.192.0 inet6 地址: fe80::21e:64ff:fef0:2337/64 Scope:Link UP BROADCAST RUNNING MULTICAST MTU:1500 跃点数:1 接收数据包:47 错误:0 丢弃:0 过载:0 帧数:0 发送数据包:177 错误:0 丢弃:0 过载:0 载波:0 碰撞:0 发送队列长度:1000 接收字节:10609 (10.6 KB) 发送字节:28519 (28.5 KB) 因为一般工控机是连接的无限网络，所以主要看wlan这边的信息（注意：有些电脑的无线网卡名称不是wlan，而是wlp60s0）。在对应的信息部分找到inet addr：xxx.xxx.xxx.xxx就是对应的IP地址。 方案二：网页上读取 如果你使用的是无线路由器建立的无线网络而且你是路由器的管理员，那么建议你使用这种方法，因为可以不用接显示器和键盘就可以知道IP。方法：在浏览器登录到设置wifi网络的网页，如192.168.1.1，tplogin.cn等，就可以通过浏览器登录到路由器后端，通过查看已连接设备的信息看到工控机的IP地址。 方案三：手机上查看 如果你是用手机建立的无线网络，可以在手机上查看工控机的IP地址。具体操作是：设置 -> （更多） -> 移动网络共享 -> 便携式WLAN热点 -> 管理设备列表，在已连接设备中找到工控机，“192.168.xx.xx”就是工控机的IP。 Copyright © 深圳朝闻道智能信息科技有限公司 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-06-02 16:12:07 "},"docs/FAQ/solution-of-handsfree-hw-error.html":{"url":"docs/FAQ/solution-of-handsfree-hw-error.html","title":"handsfree_hw节点出现错误","keywords":"","body":"运行roslaunch handsfree_hw handsfree_hw.launch出现问题的解决方案 请仔细查看错误原因： config file can't be opened, check your system 请参考可能原因四 Failed to open the serial port 请参考可能原因二 time out 请参考可能原因一和可能原因三 可能原因一：串口线没有插好或者PC端占用的COM口不是ttyUSB0 解决办法：确保只有单片机的USB线插在工控机上，拔掉激光、摄像头的USB线。打开一个终端，输入： ls /dev/ttyUSB* 如果显示的USB设备不是ttyUSB0，则拔掉所有USB线，重新插入PC，再次检查是否为ttyUSB0设备号。 可能原因二：权限不够，不能打开USB口进行通信 解决办法：使用以下命令修改ttyUSB0的权限： sudo chmod 777 /dev/ttyUSB0 可能原因三：主控板中的固件烧写不正确 由于版本差异等原因，固件烧写错误会导致通讯错误，出现timeout错误。 解决办法：根据移动底盘的型号、OpenRe的版本和Hnads-Free ROS代码的版本重新选择固件进行烧写。 可能原因四：没有改程序中的路径 handsfree的源码clone下来之后，要去handsfree/handsfree_hw/src/main.cpp里面把\"/home/luyifan/handsfree_ws/src/handsfree/handsfree_hw/config.txt\")改成自己的电脑里面对应的路径，再重新编译。 Copyright © 深圳朝闻道智能信息科技有限公司 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-06-02 16:12:07 "},"docs/FAQ/OpenRE-make&make-burn-error.html":{"url":"docs/FAQ/OpenRE-make&make-burn-error.html","title":"OpenRE编译和烧录报错","keywords":"","body":"在用make和make burn指令编译烧录OpenRE代码的时候出现错误 可能原因一：连线没有正确 检查一下jlink的连线，其中有的机器人发货的时候是用的四根杜邦线连接的jlink电路板和一个转接板，四根线不要插错，检查以下对应的口有没有插对。 编译和烧录工具没有安装好 在OpenRE环境配置中，选择方法二。有些电脑不适用方法一。 Copyright © 深圳朝闻道智能信息科技有限公司 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-06-02 16:12:07 "},"docs/FAQ/reason-for-alarming.html":{"url":"docs/FAQ/reason-for-alarming.html","title":"机器人滴滴报警怎么办","keywords":"","body":"机器人滴滴滴报警解决方案 可能原因一：电池电量不足 用万用表测量一下电池电压，电压低于11v就要充电了。 可能原因二：程序出现异常 将单片机复位一下，如果还是不行，将整个机器人所有环节（包括单片机和ROS端）重启。如果重启后，没有问题了，过了几分钟又报警，那就是电池电量不足。 Copyright © 深圳朝闻道智能信息科技有限公司 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-06-02 16:12:07 "},"docs/FAQ/environment_config.html":{"url":"docs/FAQ/environment_config.html","title":"如何配置环境","keywords":"","body":"如何配置环境 本节介绍如何在Ubuntu 14.04和16.04上安装ros并配置HandsFree程序，HandsFree支持ROS的indigo版本和Kinetic，ubuntu14.04上只支持indigo，ubuntu16.04上只支持kinetic，可以参考ROS 官方安装教程。 一键安装脚本 如果你是HandsFree平台的用户，你安装完ubuntu后，可以通过运行我们提供的一键安装脚本来配置系统开发环境、安装ROS、和安装HandsFree的ROS程序。你可以根据使用系统的版本来选择下列的一键安装脚本。Tips：正常情况下，我们是安装配置好环境发货的，此一键安装脚本，是为了方便HandsFree用户自己开发研究。 Tips查看系统版本命令 ： cat /etc/os-release 如果你的系统版本是ubuntu14.04，那么安装HandsFree indigo： cd ~ wget https://raw.githubusercontent.com/HANDS-FREE/handsfree/master/Documentation/auto_install_all_ubuntu14.04.sh sh auto_install_all_ubuntu14.04.sh 如果你的系统版本是ubuntu16.04，安装HandsFree kinetic： cd ~ wget https://raw.githubusercontent.com/HANDS-FREE/handsfree/master/Documentation/auto_install_all_ubuntu16.04.sh sh auto_install_all_ubuntu16.04.sh 一键安装脚本执行成功后，可以直接跳过下一步的\"一步步安装\"，直接进入测试部分，如果安装过程中失败或者测试失败，则按照\"一步步安装\"教程重新安装。 一步步安装 为了方便用户开发理解和防止以上一键安装脚本失败的情况，我们这里也提供一步步安装的方法。 1.安装操作系统（此处略，ubuntu14.04/ubuntu16.04） 2.下载HandsFree的代码 sudo apt-get update sudo apt-get install -y git mkdir -p ~/handsfree/handsfree_ros_ws/ cd ~/handsfree/handsfree_ros_ws/ echo 设置 HandsFree 安装路径为： ~/handsfree git clone https://github.com/HANDS-FREE/handsfree.git src cd ~/handsfree/handsfree_ros_ws/src/Documentation sudo cp /etc/apt/sources.list /etc/apt/sources.list.backup sudo cp ./script/sources_ubuntu_14_04.list /etc/apt/sources.list sudo apt-get update 3.配置系统开发环境 这里顺便教大家如何科学的配置ubuntu开发环境，一次性安装了大量的常用工具和库。 如果你的系统版本是ubuntu14.04： cd cd ~/handsfree/handsfree_ros_ws/src/Documentation sh auto_set_ubuntu14.04.sh 如果你的系统版本是ubuntu16.04： cd cd ~/handsfree/handsfree_ros_ws/src/Documentation sh auto_set_ubuntu16.04.sh 3.安装ROS 此步骤也可以按照官方教程来，ROS 官方安装教程 如果你的系统版本是ubuntu14.04：(其中可能需要管理员密码) cd cd ~/handsfree/handsfree_ros_ws/src/Documentation sh ros_indigo_base.sh 如果你的系统版本是ubuntu16.04：(其中可能需要管理员密码) cd cd ~/handsfree/handsfree_ros_ws/src/Documentation sh ros_kinetic_base.sh 安装结束后，关闭终端，测试一下，在终端中分别运行： roscore 和 rosrun turtlesim turtlesim_node 如果出现了小乌龟，说明安装成功啦。 4.安装ROS常用第三方包 安装完最基本的ROS，还是不够，很多常用的ROS的第三方包还需要自己手动安装。 如果你的系统版本是ubuntu14.04： cd cd ~/handsfree/handsfree_ros_ws/src/Documentation sh ros_indigo_ext.sh 如果你的系统版本是ubuntu16.04： cd cd ~/handsfree/handsfree_ros_ws/src/Documentation sh ros_kinetic_ext.sh 4.安装HandsFree ROS包 source ~/.bashrc cd ~/handsfree/handsfree_ros_ws/src/ catkin_init_workspace catkin_make echo \"source ~/handsfree/handsfree_ros_ws/devel/setup.sh\" >> ~/.bashrc source ~/.bashrc HandsFree 相关程序已经安装完毕 安装路径为：~/handsfree 5.设置HandsFree环境变量 打开用户bashrc gedit .bashrc 找到环境变量**HANDSFREE_ROBOT_MODEL** 把HANDSFREE_ROBOT_MODEL设置成你的机器人模型，2018.7月以后买到的stone为stone_v3，7月之前的为stone_v2. ### MODEL type [mini, stone_v2, stone_v3, giraffe] export HANDSFREE_ROBOT_MODEL=stone_v2 测试 安装成功后可以使用USB连接到机器人，然后执行： roslaunch handsfree_hw handsfree_hw.launch 如果一切正常，会显示： auto-starting new master process[master]: started with pid [9562] ROS_MASTER_URI=http://Robot:11311 setting /run_id to ffa41cce-05bd-11e8-8df0-001e64f02337 process[rosout-1]: started with pid [9575] started core service [/rosout] process[handsfree_hw_node-2]: started with pid [9585] process[mobile_base/controller_spawner-3]: started with pid [9589] process[robot_state_publisher-4]: started with pid [9591] [ERROR] [1517317423.863958024]: hf link initialized failed, please check the hardware [INFO] [WallTime: 1517317424.295263] Controller Spawner: Waiting for service controller_manager/load_controller [INFO] [WallTime: 1517317424.298319] Controller Spawner: Waiting for service controller_manager/switch_controller [INFO] [WallTime: 1517317424.301498] Controller Spawner: Waiting for service controller_manager/unload_controller [INFO] [WallTime: 1517317424.304670] Loading controller: joint_state_controller [INFO] [WallTime: 1517317424.351596] Loading controller: servo1_position_controller [INFO] [WallTime: 1517317424.399306] Loading controller: servo2_position_controller [INFO] [WallTime: 1517317424.419282] Loading controller: mobile_base_controller [INFO] [WallTime: 1517317424.469234] Controller Spawner: Loaded controllers: joint_state_controller, servo1_position_controller, servo2_position_controller, mobile_base_controller [INFO] [WallTime: 1517317424.479183] Started controllers: joint_state_controller, servo1_position_controller, servo2_position_controller, mobile_base_controller 打开新的终端，继续执行： roslaunch handsfree_hw keyboard_teleop.launch 来遥控机器人行走。 如果如上图显示，则说明连接成功，如果出现err或timeout，请参考常见问题 Copyright © 深圳朝闻道智能信息科技有限公司 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-06-02 16:12:07 "},"docs/FAQ/how-to-use-mirror.html":{"url":"docs/FAQ/how-to-use-mirror.html","title":"HandsFree系统镜像","keywords":"","body":"Copyright © 深圳朝闻道智能信息科技有限公司 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-06-02 16:12:07 "}}